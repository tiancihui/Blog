<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">50</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">79</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/raft/" class="post-title-link" itemprop="url">深入剖析共识性算法 Raft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-01 22:07:00" itemprop="dateCreated datePublished" datetime="2020-02-01T22:07:00+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/raft/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/raft/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入剖析共识性算法-raft"><a class="markdownIt-Anchor" href="#深入剖析共识性算法-raft"></a> 深入剖析共识性算法 Raft</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<p><img src="http://dunwu.test.upcdn.net/snap/20200201221202.png" alt="img" /></p>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80raft-%E7%AE%80%E4%BB%8B">一、Raft 简介</a>
<ul>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7">分布式一致性</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA">复制状态机</a></li>
<li><a href="#raft-%E5%BA%94%E7%94%A8">RAFT 应用</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Craft-%E5%9F%BA%E7%A1%80">二、Raft 基础</a>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E8%89%B2">服务器角色</a></li>
<li><a href="#%E4%BB%BB%E6%9C%9F">任期</a></li>
<li><a href="#rpc">RPC</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E9%80%89%E4%B8%BE-leader">三、选举 Leader</a>
<ul>
<li><a href="#%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99">选举规则</a></li>
<li><a href="#%E5%8D%95-candidate-%E9%80%89%E4%B8%BE">单 Candidate 选举</a></li>
<li><a href="#%E5%A4%9A-candidate-%E9%80%89%E4%B8%BE">多 Candidate 选举</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6">四、日志复制</a>
<ul>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">日志格式</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B">日志复制流程</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E4%B8%80%E8%87%B4%E6%80%A7">日志一致性</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%AE%89%E5%85%A8%E6%80%A7">五、安全性</a>
<ul>
<li><a href="#%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6">选举限制</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E6%97%A7%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE">提交旧任期的日志条目</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9">六、日志压缩</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-raft-简介"><a class="markdownIt-Anchor" href="#一-raft-简介"></a> 一、Raft 简介</h2>
<p><strong><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft</a> _是一种为了管理日志复制的分布式一致性算法</strong>*。</p>
<p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft</a> 出现之前，Paxos 一直是分布式一致性算法的标准。Paxos <strong>难以理解，更难以实现</strong>。Raft 的设计目标是简化 Paxos，使得算法<strong>既容易理解，也容易实现</strong>。</p>
<p>Paxos 和 Raft 都是分布式一致性算法，这个过程如同投票选举领袖（Leader），参选者（Candidate）需要说服大多数投票者（Follower）投票给他，一旦选举出领袖，就由领袖发号施令。Paxos 和 Raft 的区别在于选举的具体过程不同。</p>
<p><strong>Raft 可以解决分布式 CAP 理论中的 CP</strong>，即 <em>一致性（C：Consistency）</em> 和 <em>分区容忍性（P：Partition Tolerance）</em>，并不能解决 <em>可用性（A：Availability）</em> 的问题。</p>
<h3 id="分布式一致性"><a class="markdownIt-Anchor" href="#分布式一致性"></a> 分布式一致性</h3>
<p>分布式一致性 (distributed consensus) 是分布式系统中最基本的问题，用来保证一个分布式系统的可靠性以及容错能力。简单来说，<em><strong>分布式一致性是指多个服务器的保持状态一致</strong></em>。</p>
<p>在分布式系统中，可能出现各种意外（断电、网络拥塞、CPU/内存耗尽等等），使得服务器宕机或无法访问，最终导致无法和其他服务器保持状态一致。为了应对这种情况，就需要有一种一致性协议来进行容错，使得分布式系统中即使有部分服务器宕机或无法访问，整体依然可以对外提供服务。</p>
<p>以容错方式达成一致，自然不能要求所有服务器都达成一致状态，只要<strong>超过半数以上</strong>的服务器达成一致就可以了。假设有 N 台服务器， 大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{N}{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 台服务器就算是半数以上了 。</p>
<h3 id="复制状态机"><a class="markdownIt-Anchor" href="#复制状态机"></a> 复制状态机</h3>
<p><strong><code>复制状态机（Replicated State Machines）</code></strong> 是指一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131233906.png" alt="img" /></p>
<p>复制状态机通常都是基于复制日志实现的，如上图。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p>保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法通常含有以下特性：</p>
<ul>
<li><strong>安全性保证</strong>（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li>
<li><strong>可用性</strong>：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。</li>
<li><strong>不依赖时序来保证一致性</strong>：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li>
<li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li>
</ul>
<h3 id="raft-应用"><a class="markdownIt-Anchor" href="#raft-应用"></a> RAFT 应用</h3>
<p>RAFT 可以做什么？</p>
<p>通过 RAFT 提供的复制状态机，可以解决分布式系统的复制、修复、节点管理等问题。Raft 极大的简化当前分布式系统的设计与实现，让开发者只关注于业务逻辑，将其抽象实现成对应的状态机即可。基于这套框架，可以构建很多分布式应用：</p>
<ul>
<li>分布式锁服务，比如 Zookeeper</li>
<li>分布式存储系统，比如分布式消息队列、分布式块系统、分布式文件系统、分布式表格系统等</li>
<li>高可靠元信息管理，比如各类 Master 模块的 HA</li>
</ul>
<h2 id="二-raft-基础"><a class="markdownIt-Anchor" href="#二-raft-基础"></a> 二、Raft 基础</h2>
<p>Raft 将一致性问题分解成了三个子问题：</p>
<ul>
<li><strong>选举 Leader</strong></li>
<li><strong>日志复制</strong></li>
<li><strong>安全性</strong></li>
</ul>
<p>在后续章节，会详细讲解这个子问题。现在，先了解一下 Raft 的一些核心概念。</p>
<h3 id="服务器角色"><a class="markdownIt-Anchor" href="#服务器角色"></a> 服务器角色</h3>
<p>在 Raft 中，任何时刻，每个服务器都处于这三个角色之一 ：</p>
<ul>
<li><strong><code>Leader</code></strong> - 领导者，通常一个系统中是<strong>一主（Leader）多从（Follower）</strong>。Leader <strong>负责处理所有的客户端请求</strong>。</li>
<li><strong><code>Follower</code></strong> - 跟随者，<strong>不会发送任何请求</strong>，只是简单的 <strong>响应来自 Leader 或者 Candidate 的请求</strong>。</li>
<li><strong><code>Candidate</code></strong> - 参选者，选举新 Leader 时的临时角色。</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131215742.png" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<ul>
<li>Follower 只响应来自其他服务器的请求。在一定时限内，如果 Follower 接收不到消息，就会转变成 Candidate，并发起选举。</li>
<li>Candidate 向 Follower 发起投票请求，如果获得集群中半数以上的选票，就会转变为 Leader。</li>
<li>在一个 Term 内，Leader 始终保持不变，直到下线了。Leader 需要周期性向所有 Follower 发送心跳消息，以阻止 Follower 转变为 Candidate。</li>
</ul>
</blockquote>
<h3 id="任期"><a class="markdownIt-Anchor" href="#任期"></a> 任期</h3>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131220742.png" alt="img" /></p>
<p>Raft 把时间分割成任意长度的 **<em><code>任期（Term）</code><em><strong>，任期用连续的整数标记。每一段任期从一次</strong>选举</em></em>开始。<strong>Raft 保证了在一个给定的任期内，最多只有一个领导者</strong>。</p>
<ul>
<li>如果选举成功，Leader 会管理整个集群直到任期结束。</li>
<li>如果选举失败，那么这个任期就会因为没有 Leader 而结束。</li>
</ul>
<p><strong>不同服务器节点观察到的任期转换状态可能不一样</strong>：</p>
<ul>
<li>服务器节点可能观察到多次的任期转换。</li>
<li>服务器节点也可能观察不到任何一次任期转换。</li>
</ul>
<p><strong>任期在 Raft 算法中充当逻辑时钟的作用，使得服务器节点可以查明一些过期的信息（比如过期的 Leader）。每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号。</strong></p>
<ul>
<li>如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。</li>
<li>如果一个 Candidate 或者 Leader 发现自己的任期号过期了，那么他会立即恢复成跟随者状态。</li>
<li>如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</li>
</ul>
<h3 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> RPC</h3>
<p>Raft 算法中服务器节点之间的通信使用 ***<code>远程过程调用（RPC）</code>***。</p>
<p>基本的一致性算法只需要两种 RPC：</p>
<ul>
<li><strong><code>RequestVote RPC</code></strong> - 请求投票 RPC，由 Candidate 在选举期间发起。</li>
<li><strong><code>AppendEntries RPC</code></strong> - 附加条目 RPC，由 Leader 发起，用来复制日志和提供一种心跳机制。</li>
</ul>
<h2 id="三-选举-leader"><a class="markdownIt-Anchor" href="#三-选举-leader"></a> 三、选举 Leader</h2>
<h3 id="选举规则"><a class="markdownIt-Anchor" href="#选举规则"></a> 选举规则</h3>
<p><strong>Raft 使用一种心跳机制来触发 Leader 选举</strong>。</p>
<p><strong>Leader 需要周期性的向所有 Follower 发送心跳消息</strong>，以此维持自己的权威并阻止新 Leader 的产生。</p>
<p>每个 Follower 都设置了一个<strong>随机的竞选超时时间</strong>，一般为 <code>150ms ~ 300ms</code>，如果在竞选超时时间内没有收到 Leader 的心跳消息，就会认为当前 Term 没有可用的 Leader，并发起选举来选出新的 Leader。开始一次选举过程，Follower 先要增加自己的当前 Term 号，并<strong>转换为 Candidate</strong>。</p>
<p>Candidate 会并行的<strong>向集群中的所有服务器节点发送投票请求（<code>RequestVote RPC</code>）</strong>，它会保持当前状态直到以下三件事情之一发生：</p>
<ul>
<li><strong>自己成为 Leader</strong></li>
<li><strong>其他的服务器成为 Leader</strong></li>
<li><strong>没有任何服务器成为 Leader</strong></li>
</ul>
<h4 id="自己成为-leader"><a class="markdownIt-Anchor" href="#自己成为-leader"></a> 自己成为 Leader</h4>
<ul>
<li>当一个 Candidate 从整个集群<strong>半数以上</strong>的服务器节点获得了针对同一个 Term 的选票，那么它就赢得了这次选举并成为 Leader。每个服务器最多会对一个 Term 投出一张选票，按照先来先服务（FIFO）的原则。<em>要求半数以上选票的规则确保了最多只会有一个 Candidate 赢得此次选举</em>。</li>
<li>一旦 Candidate 赢得选举，就立即成为 Leader。然后它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</li>
</ul>
<h4 id="其他的服务器成为-leader"><a class="markdownIt-Anchor" href="#其他的服务器成为-leader"></a> 其他的服务器成为 Leader</h4>
<p>等待投票期间，Candidate 可能会从其他的服务器接收到声明它是 Leader 的 <code>AppendEntries RPC</code>。</p>
<ul>
<li>如果这个 Leader 的 Term 号（包含在此次的 RPC 中）不小于 Candidate 当前的 Term，那么 Candidate 会承认 Leader 合法并回到 Follower 状态。</li>
<li>如果此次 RPC 中的 Term 号比自己小，那么 Candidate 就会拒绝这个消息并继续保持 Candidate 状态。</li>
</ul>
<h4 id="没有任何服务器成为-leader"><a class="markdownIt-Anchor" href="#没有任何服务器成为-leader"></a> 没有任何服务器成为 Leader</h4>
<p>如果有多个 Follower 同时成为 Candidate，那么选票可能会被瓜分以至于没有 Candidate 可以赢得半数以上的投票。当这种情况发生的时候，每一个 Candidate 都会竞选超时，然后通过增加当前 Term 号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，竞选超时时间是一个<strong>随机的时间</strong>，在一个固定的区间（例如 150-300 毫秒）随机选择，这样可以把选举都分散开。</p>
<ul>
<li>以至于在大多数情况下，只有一个服务器会超时，然后它赢得选举，成为 Leader，并在其他服务器超时之前发送心跳包。</li>
<li>同样的机制也被用在选票瓜分的情况下：每一个 Candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。</li>
</ul>
<hr />
<p>理解了上面的选举规则后，我们通过动图来加深认识。</p>
<h3 id="单-candidate-选举"><a class="markdownIt-Anchor" href="#单-candidate-选举"></a> 单 Candidate 选举</h3>
<p>（1）下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的选举超时时间之后，没收到 Leader 发来的心跳消息。因此，将 Term 由 0 增加为 1，转换为 Candidate，进入选举状态。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-01.gif" alt="img" /></p>
<p>（2）此时，A 向所有其他节点发送投票请求。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-02.gif" alt="img" /></p>
<p>（3）其它节点会对投票请求进行回复，如果超过半数以上的节点投票了，那么该 Candidate 就会立即变成 Term 为 1 的 Leader。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-03.gif" alt="img" /></p>
<p>（4）Leader 会周期性地发送心跳消息给所有 Follower，Follower 接收到心跳包，会重新开始计时。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-04.gif" alt="img" /></p>
<h3 id="多-candidate-选举"><a class="markdownIt-Anchor" href="#多-candidate-选举"></a> 多 Candidate 选举</h3>
<p>（1）如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Candidate B 和 Candidate D 都发起 Term 为 4 的选举，且都获得两票，因此需要重新开始投票。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-01.gif" alt="img" /></p>
<p>（2）当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-02.gif" alt="img" /></p>
<h2 id="四-日志复制"><a class="markdownIt-Anchor" href="#四-日志复制"></a> 四、日志复制</h2>
<h3 id="日志格式"><a class="markdownIt-Anchor" href="#日志格式"></a> 日志格式</h3>
<p><strong>日志由含日志索引（log index）的日志条目（log entry）组成</strong>。每个日志条目包含它被创建时的 Term 号（下图中方框中的数字），和一个复制状态机需要执行的指令。如果一个日志条目被复制到半数以上的服务器上，就被认为可以提交（Commit）了。</p>
<ul>
<li>日志条目中的 Term 号被用来检查是否出现不一致的情况。</li>
<li>日志条目中的日志索引（一个整数值）用来表明它在日志中的位置。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ee29a89e4eb63468e142bb6103dbe4de_hd.jpg" alt="img" /></p>
<p>Raft 日志同步保证如下两点：</p>
<ul>
<li>如果不同日志中的两个日志条目有着相同的日志索引和 Term，则<strong>它们所存储的命令是相同的</strong>。
<ul>
<li>这个特性基于这条原则：Leader 最多在一个 Term 内、在指定的一个日志索引上创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。</li>
</ul>
</li>
<li>如果不同日志中的两个日志条目有着相同的日志索引和 Term，则<strong>它们之前的所有条目都是完全一样的</strong>。
<ul>
<li>这个特性由 <code>AppendEntries RPC</code> 的一个简单的一致性检查所保证。在发送 <code>AppendEntries RPC</code> 时，Leader 会把新日志条目之前的日志条目的日志索引和 Term 号一起发送。如果 Follower 在它的日志中找不到包含相同日志索引和 Term 号的日志条目，它就会拒绝接收新的日志条目。</li>
</ul>
</li>
</ul>
<h3 id="日志复制流程"><a class="markdownIt-Anchor" href="#日志复制流程"></a> 日志复制流程</h3>
<p><img src="http://dunwu.test.upcdn.net/snap/20200201115848.png" alt="img" /></p>
<ol>
<li>Leader 负责处理所有客户端的请求。</li>
<li>Leader 把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发送 <code>AppendEntries RPC</code> 请求，要求 Follower 复制日志条目。</li>
<li>Follower 复制成功后，返回确认消息。</li>
<li>当这个日志条目被半数以上的服务器复制后，Leader 提交这个日志条目到它的复制状态机，并向客户端返回执行结果。</li>
</ol>
<blockquote>
<p>注意：如果 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 会不断的重复尝试发送 <code>AppendEntries RPC</code> 请求 （尽管已经回复了客户端），直到所有的跟随者都最终复制了所有的日志条目。</p>
</blockquote>
<p>下面，通过一组动图来加深认识：</p>
<p>（1）来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-01.gif" alt="img" /></p>
<p>（2）Leader 会把修改复制到所有 Follower。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-02.gif" alt="img" /></p>
<p>（3）Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-03.gif" alt="img" /></p>
<p>（4）此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-04.gif" alt="img" /></p>
<h3 id="日志一致性"><a class="markdownIt-Anchor" href="#日志一致性"></a> 日志一致性</h3>
<p>一般情况下，Leader 和 Followers 的日志保持一致，因此日志条目一致性检查通常不会失败。然而，Leader 崩溃可能会导致日志不一致：旧的 Leader 可能没有完全复制完日志中的所有条目。</p>
<h4 id="leader-和-follower-日志不一致的可能"><a class="markdownIt-Anchor" href="#leader-和-follower-日志不一致的可能"></a> Leader 和 Follower 日志不一致的可能</h4>
<p>Leader 和 Follower 可能存在多种日志不一致的可能。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d36c587901391cae50788061f568d24f_hd.jpg" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<p>上图阐述了 Leader 和 Follower 可能存在多种日志不一致的可能，每一个方框表示一个日志条目，里面的数字表示任期号 。</p>
<p>当一个 Leader 成功当选时，Follower 可能出现以下情况（a-f）：</p>
<ul>
<li><strong>存在未更新日志条目</strong>，如（a、b）。</li>
<li><strong>存在未提交日志条目</strong>，如（c、d）。</li>
<li>或<strong>两种情况都存在</strong>，如（e、f）。</li>
</ul>
<p><em>例如，场景 f 可能会这样发生，某服务器在 Term2 的时候是 Leader，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在 Term3 重新被选为 Leader，并且又增加了一些日志条目到自己的日志中；在 Term 2 和 Term 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态</em>。</p>
</blockquote>
<h4 id="leader-和-follower-日志一致的保证"><a class="markdownIt-Anchor" href="#leader-和-follower-日志一致的保证"></a> Leader 和 Follower 日志一致的保证</h4>
<p>Leader 通过强制 Followers 复制它的日志来处理日志的不一致，<strong>Followers 上的不一致的日志会被 Leader 的日志覆盖</strong>。</p>
<ul>
<li>
<p>Leader 为了使 Followers 的日志同自己的一致，Leader 需要找到 Followers 同它的日志一致的地方，然后覆盖 Followers 在该位置之后的条目。</p>
</li>
<li>
<p>Leader 会从后往前试，每次日志条目失败后尝试前一个日志条目，直到成功找到每个 Follower 的日志一致位点，然后向后逐条覆盖 Followers 在该位置之后的条目。</p>
</li>
</ul>
<h2 id="五-安全性"><a class="markdownIt-Anchor" href="#五-安全性"></a> 五、安全性</h2>
<p>前面描述了 Raft 算法是如何选举 Leader 和复制日志的。</p>
<p>Raft 还增加了一些限制来完善 Raft 算法，以保证安全性：保证了任意 Leader 对于给定的 Term，都拥有了之前 Term 的所有被提交的日志条目。</p>
<h3 id="选举限制"><a class="markdownIt-Anchor" href="#选举限制"></a> 选举限制</h3>
<p>拥有最新的已提交的日志条目的 Follower 才有资格成为 Leader。</p>
<p>Raft 使用投票的方式来阻止一个 Candidate 赢得选举除非这个 Candidate 包含了所有已经提交的日志条目。 Candidate 为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果 Candidate 的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。</p>
<p><code>RequestVote RPC</code> 实现了这样的限制：<strong>RequestVote RPC 中包含了 Candidate 的日志信息， Follower 会拒绝掉那些日志没有自己新的投票请求</strong>。</p>
<p>如何判断哪个日志条目比较新？</p>
<p>Raft 通过比较两份日志中最后一条日志条目的日志索引和 Term 来判断哪个日志比较新。</p>
<ul>
<li>先判断 Term，哪个数值大即代表哪个日志比较新。</li>
<li>如果 Term 相同，再比较 日志索引，哪个数值大即代表哪个日志比较新。</li>
</ul>
<h3 id="提交旧任期的日志条目"><a class="markdownIt-Anchor" href="#提交旧任期的日志条目"></a> 提交旧任期的日志条目</h3>
<p>一个当前 Term 的日志条目被复制到了半数以上的服务器上，Leader 就认为它是可以被提交的。如果这个 Leader 在提交日志条目前就下线了，后续的 Leader 可能会覆盖掉这个日志条目。</p>
<p><img src="https://pic4.zhimg.com/80/v2-12a5ebab63781f9ec49e14e331775537_hd.jpg" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<p>上图解释了为什么 Leader 无法对旧 Term 的日志条目进行提交。</p>
<ul>
<li>阶段 (a) ，S1 是 Leader，且 S1 写入日志条目为 (Term 2，日志索引 2），只有 S2 复制了这个日志条目。</li>
<li>阶段 (b)，S1 下线，S5 被选举为 Term3 的 Leader。S5 写入日志条目为 (Term 3，日志索引 2）。</li>
<li>阶段 ©，S5 下线，S1 重新上线，并被选举为 Term4 的 Leader。此时，Term 2 的那条日志条目已经被复制到了集群中的大多数节点上，但是还没有被提交。</li>
<li>阶段 (d)，S1 再次下线，S5 重新上线，并被重新选举为 Term3 的 Leader。然后 S5 覆盖了日志索引 2 处的日志。</li>
<li>阶段 (e)，如果阶段 (d) 还未发生，即 S1 再次下线之前，S1 把自己主导的日志条目复制到了大多数节点上，那么在后续 Term 里面这些新日志条目就会被提交。这样在同一时刻就同时保证了，之前的所有旧日志条目就会被提交。</li>
</ul>
</blockquote>
<p><strong>Raft 永远不会通过计算副本数目的方式去提交一个之前 Term 内的日志条目</strong>。只有 Leader 当前 Term 里的日志条目通过计算副本数目可以被提交；一旦当前 Term 的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。</p>
<p>当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的 Term，这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p>
<h2 id="六-日志压缩"><a class="markdownIt-Anchor" href="#六-日志压缩"></a> 六、日志压缩</h2>
<p>在实际的系统中，不能让日志无限膨胀，否则系统重启时需要花很长的时间进行恢复，从而影响可用性。Raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态生成快照，并且只能对已经提交的日志条目生成快照。</p>
<p>快照包含以下内容：</p>
<ul>
<li>日志元数据。最后一条已提交的日志条目的日志索引和 Term。这两个值在快照之后的第一条日志条目的 <code>AppendEntries RPC</code> 的完整性检查的时候会被用上。</li>
<li>系统当前状态。</li>
</ul>
<p>当 Leader 要发送某个日志条目，落后太多的 Follower 的日志条目会被丢弃，Leader 会将快照发给 Follower。或者新上线一台机器时，也会发送快照给它。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200201220628.png" alt="img" /></p>
<p><strong>生成快照的频率要适中</strong>，频率过高会消耗大量 I/O 带宽；频率过低，一旦需要执行恢复操作，会丢失大量数据，影响可用性。推荐当日志达到某个固定的大小时生成快照。</p>
<p>生成一次快照可能耗时过长，影响正常日志同步。可以通过使用 copy-on-write 技术避免快照过程影响正常日志同步。</p>
<blockquote>
<p>说明：本文仅阐述 Raft 算法的核心内容，不包括算法论证、评估等</p>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft 一致性算法论文原文</a></li>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">Raft 一致性算法论文译文</a></li>
<li><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&amp;feature=youtu.be" target="_blank" rel="noopener">Raft 作者讲解视频</a></li>
<li><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt" target="_blank" rel="noopener">Raft 作者讲解视频对应的 PPT</a></li>
<li><a href="https://www.jdon.com/artichect/raft.html" target="_blank" rel="noopener">分布式系统的 Raft 算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Raft 算法详解</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a> - 一个动画教程</li>
<li><a href="https://github.com/sofastack/sofa-jraft" target="_blank" rel="noopener">sofa-jraft</a> - 蚂蚁金服的 Raft 算法实现库（Java 版）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/tools/markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/tools/markdown/" class="post-title-link" itemprop="url">Markdown Cheat Sheet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-27T00:00:00+08:00">2020-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/" itemprop="url" rel="index">
                    <span itemprop="name">效率提升</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E8%A7%84%E8%8C%83/" itemprop="url" rel="index">
                    <span itemprop="name">规范</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/tools/markdown/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="tools/markdown/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="markdown-cheat-sheet"><a class="markdownIt-Anchor" href="#markdown-cheat-sheet"></a> Markdown Cheat Sheet</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E6%A0%87%E9%A2%98">标题</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F">文本样式</a></li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E7%BA%BF">分割线</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE">代码高亮</a></li>
<li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="#emoji-%E8%A1%A8%E6%83%85">Emoji 表情</a></li>
<li><a href="#%E6%B3%A8%E8%84%9A">注脚</a></li>
<li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">数学公式</a></li>
<li><a href="#diff">Diff</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li>
<li><a href="#html">HTML</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2>
<p>Markdown 支持六个级别的标题。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<h2 id="文本样式"><a class="markdownIt-Anchor" href="#文本样式"></a> 文本样式</h2>
<blockquote>
<p>💡 粗体、斜体、删除线可以混合使用。</p>
<p>在 Markdown 中，粗体文本、斜体文本可以使用 <code>*</code> 或 <code>_</code> 符号标记。建议统一风格，始终只用一种符号。</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通文本</td>
<td>普通文本</td>
</tr>
<tr>
<td><code>*斜体文本*</code> <code>_斜体文本_</code></td>
<td><em>斜体文本</em> <em>斜体文本</em></td>
</tr>
<tr>
<td><code>**粗体文本**</code> <code>__粗体文本__</code></td>
<td><strong>粗体文本</strong> <strong>粗体文本</strong></td>
</tr>
<tr>
<td><code>~~删除文本~~</code></td>
<td><s>删除文本</s></td>
</tr>
<tr>
<td><code>***粗斜体文本***</code> <code>___粗斜体文本___</code></td>
<td><em><strong>粗斜体文本</strong></em> <em><strong>粗斜体文本</strong></em></td>
</tr>
</tbody>
</table>
<h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2>
<h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3>
<ul>
<li>RED</li>
<li>YELLOW</li>
<li>BLUE</li>
</ul>
<h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3>
<ol>
<li>第一步</li>
<li>第二步</li>
<li>第三步</li>
</ol>
<h3 id="任务列表"><a class="markdownIt-Anchor" href="#任务列表"></a> 任务列表</h3>
<ul>
<li>[x] 完成任务</li>
<li>[ ] 计划任务</li>
</ul>
<h3 id="多级列表"><a class="markdownIt-Anchor" href="#多级列表"></a> 多级列表</h3>
<ul>
<li>数据结构
<ul>
<li>线性表
<ul>
<li>顺序表</li>
<li>链表
<ul>
<li>单链表</li>
<li>双链表</li>
</ul>
</li>
</ul>
</li>
<li>树
<ul>
<li>二叉树
<ul>
<li>二叉平衡树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分割线"><a class="markdownIt-Anchor" href="#分割线"></a> 分割线</h2>
<p><code>***</code>、<code>---</code>、<code>___</code> 都可以作为分割线。</p>
<hr />
<hr />
<hr />
<h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2>
<h3 id="普通链接"><a class="markdownIt-Anchor" href="#普通链接"></a> 普通链接</h3>
<p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>](<span class="link">https://dunwu.github.io/blog/</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[]</code> 中标记链接名。类似 HTML 中 <code>&lt;a&gt;</code> 元素的 <code>title</code> 属性。</li>
<li><code>()</code> 中标记链接的 url，也支持相对路径（前提是资源可以访问）。类似 HTML 中 <code>&lt;a&gt;</code> 元素的 <code>href</code> 属性。</li>
</ul>
<p>效果：</p>
<ul>
<li><a href="https://dunwu.github.io/blog/" title="blog">我的博客</a></li>
</ul>
<h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3>
<p>Markdown 引用图片的语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">url title</span>)</span><br></pre></td></tr></table></figure>
<p>alt 和 title 即对应 HTML 中 img 元素的 alt 和 title 属性（都可省略）：</p>
<ul>
<li>
<p>alt - 表示图片显示失败时的替换文本。</p>
</li>
<li>
<p>title - 表示鼠标悬停在图片时的显示文本（注意这里要加引号）</p>
</li>
<li>
<p>url - 即图片的 url 地址</p>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/common/logo/zp.png" alt="logo" title="logo" /></p>
<h3 id="图片链接"><a class="markdownIt-Anchor" href="#图片链接"></a> 图片链接</h3>
<p>可以将图片和链接混合使用。</p>
<p><a href="https://dunwu.github.io/blog/"><img src="http://dunwu.test.upcdn.net/common/logo/zp.png" alt="logo" title="logo" /></a></p>
<h3 id="锚点"><a class="markdownIt-Anchor" href="#锚点"></a> 锚点</h3>
<p>其实呢，每一个标题都是一个锚点，和 HTML 的锚点（<code>#</code>）类似，比如：<a href="#Markdown-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97">回到顶部</a></p>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<p>普通引用：</p>
<blockquote>
<p>❓ 什么是 <code>Markdown</code></p>
<p><strong>Markdown</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">轻量级标记语言</a>，创始人为<a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF" target="_blank" rel="noopener">约翰·格鲁伯</a>（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的<a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a>（或者<a href="https://zh.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>）文档”。[<a href="https://zh.wikipedia.org/wiki/Markdown#cite_note-md-4" target="_blank" rel="noopener">4]</a>这种语言吸收了很多在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">电子邮件</a>中已有的纯文本标记的特性。 —— 摘自 Wiki</p>
</blockquote>
<p>嵌套引用：</p>
<blockquote>
<p>数据结构</p>
<blockquote>
<p>树</p>
<blockquote>
<p>二叉树</p>
<blockquote>
<p>平衡二叉树</p>
<blockquote>
<p>满二叉树</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="代码高亮"><a class="markdownIt-Anchor" href="#代码高亮"></a> 代码高亮</h2>
<h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3>
<p>语法：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`Markdown` `Doc`</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><code>Markdown</code>, <code>Doc</code></p>
<h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3>
<p>语法一：在文本前后都使用三个反引号进行标记。【✔️ 推荐】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个文本块。</span><br><span class="line">这是一个文本块。</span><br><span class="line">这是一个文本块。</span><br></pre></td></tr></table></figure>
<p>语法二：在连续几行的文本开头加入 1 个 Tab 或者 4 个空格。【❌ 不推荐】</p>
<pre><code>这是一个文本块。
这是一个文本块。
这是一个文本块。
</code></pre>
<h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3>
<p>在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;&#125; <span class="comment">//Java</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//C</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello GitHub"</span> <span class="comment">#Bash</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myH1'</span>).innerHTML = <span class="string">'Welcome to my Homepage'</span> <span class="comment">//javascipt</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; A,<span class="keyword">const</span> <span class="built_in">string</span>&amp; B) <span class="comment">//cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2>
<p>一般表格：</p>
<table>
<thead>
<tr>
<th>表头 1</th>
<th>表头 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>表格单元</td>
<td>表格单元</td>
</tr>
<tr>
<td>表格单元</td>
<td>表格单元</td>
</tr>
</tbody>
</table>
<p>表格可以指定对齐方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">商品</th>
<th style="text-align:right">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">电脑</td>
<td style="text-align:right">6000.0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">鼠标</td>
<td style="text-align:right">100.0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">键盘</td>
<td style="text-align:right">200.0</td>
</tr>
</tbody>
</table>
<h2 id="emoji-表情"><a class="markdownIt-Anchor" href="#emoji-表情"></a> Emoji 表情</h2>
<blockquote>
<p>💡 注意：部分 Markdown 引擎支持 Emoji。</p>
</blockquote>
<p>合理使用 Emoji 表情，往往可以使得文章内容更加丰富生动。例如：✔️ ❌ 💡 🔔 ❗️ ❓</p>
<blockquote>
<p>更多 Emoji 表情请参考：</p>
<ul>
<li><a href="http://emojihomepage.com/" target="_blank" rel="noopener">http://emojihomepage.com/</a></li>
<li><a href="http://www.emoji-cheat-sheet.com" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a></li>
</ul>
</blockquote>
<h2 id="注脚"><a class="markdownIt-Anchor" href="#注脚"></a> 注脚</h2>
<blockquote>
<p>💡 注意：部分 Markdown 引擎支持注脚。</p>
</blockquote>
<p>一个具有注脚的文本。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="数学公式"><a class="markdownIt-Anchor" href="#数学公式"></a> 数学公式</h2>
<blockquote>
<p>💡  注意：部分 Markdown 引擎支持 Latex。</p>
</blockquote>
<p>很多文档中，需要引入一些数学符号、特殊符号，其排版问题比较头疼。这种问题，可以用 Latex 来解决，大部分 Markdown 引擎都支持 Latex。</p>
<p>Latex 可以使用 <code>$</code> 符号来标记 Latex 表达式，下面是一个数学公式示例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mi>z</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>列举一些常用数学符号：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span></td>
<td><code>$\leq$</code></td>
<td>小于等于</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span></td>
<td><code>$\geq$</code></td>
<td>大于等于</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span></td>
<td><code>$\neq$</code></td>
<td>不等于</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span></span></span></span></td>
<td><code>$\approx$</code></td>
<td>约等于</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></td>
<td><code>$\infty$</code></td>
<td>无穷</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∏</mo><mi>x</mi><mi>y</mi></msubsup></mrow><annotation encoding="application/x-tex">\prod_{x}^{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span></td>
<td><code>$\prod_{x}^{y}$</code></td>
<td>累乘</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span></td>
<td><code>$\sum_{i=0}^n$</code></td>
<td>求和</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∫</mo></mrow><annotation encoding="application/x-tex">\int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11112em;vertical-align:-0.30612em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span></span></span></span></td>
<td><code>$\int$</code></td>
<td>积分</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∬</mo></mrow><annotation encoding="application/x-tex">\iint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0004999999999999727em;">∬</span></span></span></span></td>
<td><code>$\iint$</code></td>
<td>双重积分</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>x</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">\log_x{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></td>
<td><code>$\log_x{y}$</code></td>
<td>对数</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{y+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><code>$x^{y+1}$</code></td>
<td>上标</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{y+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></td>
<td><code>$x_{y+1}$</code></td>
<td>下标</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{x}{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td>
<td><code>$\frac{x}{y}$</code></td>
<td>分数</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mroot><mi>x</mi><mi>y</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[y]{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5516160000000001em;"><span style="top:-2.836336em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span></td>
<td><code>$\sqrt[y]{x}$</code></td>
<td>开方</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>sin</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\sin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">sin</span></span></span></span></td>
<td><code>$\sin$</code></td>
<td>正弦</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>cos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\cos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">cos</span></span></span></span></td>
<td><code>$\cos$</code></td>
<td>余弦</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>tan</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\tan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mop">tan</span></span></span></span></td>
<td><code>$\tan$</code></td>
<td>正切</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多数学符号支持请参考：</p>
<ul>
<li><a href="https://github.com/luong-komorebi/Begin-Latex-in-minutes" target="_blank" rel="noopener">Begin-Latex-in-minutes</a></li>
<li><a href="https://blog.csdn.net/Katherine_hsr/article/details/79179622" target="_blank" rel="noopener">Markdown 数学符号&amp;公式</a></li>
</ul>
</blockquote>
<h2 id="diff"><a class="markdownIt-Anchor" href="#diff"></a> Diff</h2>
<blockquote>
<p>💡  注意：部分 Markdown 引擎支持 Diff。</p>
</blockquote>
<p>版本控制的系统中都少不了 diff 的功能，即展示一个文件内容的增加与删除。<br />
GFM 中可以显示的展示 diff 效果。可以用 <code>+</code> 开头表示新增，<code>-</code> 开头表示删除。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增内容</span></span><br><span class="line"><span class="deletion">- 删除内容</span></span><br></pre></td></tr></table></figure>
<h2 id="uml-图"><a class="markdownIt-Anchor" href="#uml-图"></a> UML 图</h2>
<blockquote>
<p>💡  注意：部分 Markdown 引擎支持 <a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid</a>。</p>
<p><a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid</a> 提供了多种 UML 图。详情请参考：<a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">mermaid 文档</a></p>
</blockquote>
<h3 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>
<h3 id="时序图"><a class="markdownIt-Anchor" href="#时序图"></a> 时序图</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">        Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    else is well</span><br><span class="line">        Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">        Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<h3 id="甘特图"><a class="markdownIt-Anchor" href="#甘特图"></a> 甘特图</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">       dateFormat  YYYY-MM-DD</span><br><span class="line">       title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">       section A section</span><br><span class="line">       Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">       Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">       Future task               :         des3, after des2, 5d</span><br><span class="line">       Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">       section Critical tasks</span><br><span class="line">       Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">       Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">       Create tests for parser             :crit, active, 3d</span><br><span class="line">       Future task in critical line        :crit, 5d</span><br><span class="line">       Create tests for renderer           :2d</span><br><span class="line">       Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">       section Documentation</span><br><span class="line">       Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">       Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">       section Last section</span><br><span class="line">       Describe gantt syntax               :after doc1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :20h</span><br><span class="line">       Add another diagram to demo page    :48h</span><br></pre></td></tr></table></figure>
<h2 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h2>
<p>有些 Markdown 引擎支持在文档中嵌入的 html 元素。</p>
<p>有些 Markdown 语法所不支持的特性，可以使用 html 元素来支持。</p>
<h3 id="折叠"><a class="markdownIt-Anchor" href="#折叠"></a> 折叠</h3>
<details>
  <summary>折叠内容一</summary>
  <p>展开才能看到的内容</p>
</details>
<details>
  <summary>折叠内容二</summary>
  <p>展开才能看到的内容</p>
</details>
<h3 id="居中"><a class="markdownIt-Anchor" href="#居中"></a> 居中</h3>
<div align="center"><p>居中显示的文本</p></div>
<h3 id="图片尺寸"><a class="markdownIt-Anchor" href="#图片尺寸"></a> 图片尺寸</h3>
<div align="center"><img width="100px" src="http://dunwu.test.upcdn.net/common/logo/zp.png" /></div>
<h2 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h2>
<p>推荐 Markdown 编辑器</p>
<ul>
<li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人认为是功能最强的 Markdown 编辑器。</li>
<li><a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">Visual Studio Code</a> - 可以通过安装插件，量身打造 Markdown 编辑器。</li>
<li><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">marktext</a> - 一款简单优雅的 Markdown 编辑器。</li>
<li><a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a> - 在线 Markdown 编辑器。</li>
<li><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">Editor.md</a> - 在线 Markdown 编辑器。</li>
<li><a href="https://maxiang.io/" target="_blank" rel="noopener">Marxico</a> - 一款专为印象笔记（Evernote）打造的 Markdown 编辑器。</li>
</ul>
<blockquote>
<p>想了解更多 Markdown 编辑器可以参考：<a href="https://zhuanlan.zhihu.com/p/69210764" target="_blank" rel="noopener">主流 Markdown 编辑器推荐</a></p>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Markdown</a></li>
<li><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">https://github.com/guodongxiaren/README</a></li>
<li><a href="https://github.com/tchapi/markdown-cheatsheet" target="_blank" rel="noopener">markdown-cheatsheet</a></li>
<li><a href="https://github.com/luong-komorebi/Begin-Latex-in-minutes" target="_blank" rel="noopener">Begin-Latex-in-minutes</a></li>
<li><a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">https://github.com/mermaid-js/mermaid</a></li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>注脚的解释 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/limiting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/limiting/" class="post-title-link" itemprop="url">限流算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 11:06:00" itemprop="dateCreated datePublished" datetime="2020-01-20T11:06:00+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/limiting/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/limiting/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="限流算法"><a class="markdownIt-Anchor" href="#限流算法"></a> 限流算法</h1>
<blockquote>
<p>在高并发场景下，为了应对瞬时海量请求的压力，保障系统的平稳运行，必须预估系统的流量阈值，通过限流规则阻断处理不过来的请求。</p>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E9%99%90%E6%B5%81%E7%AE%80%E4%BB%8B">一、限流简介</a></li>
<li><a href="#%E4%BA%8C%E8%AE%A1%E6%95%B0%E5%99%A8%E6%B3%95">二、计数器法</a></li>
<li><a href="#%E4%B8%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95">三、滑动窗口法</a></li>
<li><a href="#%E5%9B%9B%E4%BB%A4%E7%89%8C%E6%A1%B6%E6%B3%95">四、令牌桶法</a></li>
<li><a href="#%E4%BA%94%E6%BC%8F%E6%A1%B6%E6%B3%95">五、漏桶法</a></li>
<li><a href="#%E5%85%AD%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7">六、限流工具</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-限流简介"><a class="markdownIt-Anchor" href="#一-限流简介"></a> 一、限流简介</h2>
<p>限流可以认为是服务降级的一种。限流就是<strong>限制系统的输入和输出流量已达到保护系统的目的</strong>。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
<p>限流规则包含三个部分：时间粒度，接口粒度，最大限流值。限流规则设置是否合理直接影响到限流是否合理有效。</p>
<h2 id="二-计数器法"><a class="markdownIt-Anchor" href="#二-计数器法"></a> 二、计数器法</h2>
<p>计数器法的<strong>原理</strong>是：设置一个计数器，用于统计指定时间段内的请求数量，并在指定时间段之后重置计数器。在这个过程中，如果请求量超过限定的阈值，则拒绝请求。</p>
<p>这种算法的缺陷是：这种算法是针对一个时间段进行统计，如果请求分布不均匀，极端情况下，<strong>所有请求都在某一刻收到，还是可能压垮系统</strong>。例如，假设我们限流规则为每秒钟不超过 100 次接口请求，第一个 1s 时间窗口内，100 次接口请求都集中在最后的 10ms 内，在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内，虽然两个时间窗口内流量都符合限流要求，但是在这两个时间窗口临界的 20ms 内会集中有 200 次接口请求，如果不做限流，集中在这 20ms 内的 200 次请求就有可能压垮系统。</p>
<p>【示例】使用 <code>AtomicInteger</code> 实现计数器法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大访问数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问时间差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; time + timeout) &#123;</span><br><span class="line">            <span class="comment">// 单位时间内</span></span><br><span class="line">            reqCount.addAndGet(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超出单位时间</span></span><br><span class="line">            time = now;</span><br><span class="line">            reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【示例】基于 Redis Lua 计数限流算法的实现</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 实现原理</span></span><br><span class="line"><span class="comment">-- 每次请求都将当前时间，精确到秒作为 key 放入 Redis 中，超时时间设置为 2s， Redis 将该 key 的值进行自增</span></span><br><span class="line"><span class="comment">-- 当达到阈值时返回错误，表示请求被限流</span></span><br><span class="line"><span class="comment">-- 写入 Redis 的操作用 Lua 脚本来完成，利用 Redis 的单线程机制可以保证每个 Redis 请求的原子性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 资源唯一标志位</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 限流大小</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前流量大小</span></span><br><span class="line"><span class="keyword">local</span> currentLimit = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currentLimit + <span class="number">1</span> &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 达到限流大小 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到阈值 value + 1</span></span><br><span class="line">    redis.call(<span class="string">"INCRBY"</span>, key, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, key, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> currentLimit + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="三-滑动窗口法"><a class="markdownIt-Anchor" href="#三-滑动窗口法"></a> 三、滑动窗口法</h2>
<p>滑动窗口法的<strong>原理</strong>：</p>
<p>滑动窗口法是计数器算法的一种改进，<strong>增加一个时间粒度的度量单位，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口</strong>。流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题。</p>
<p>对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 在临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题，</p>
<p>比如在上文的例子中，通过滑动窗口算法整型后，第一个 1s 的时间窗口的 100 次请求都会通过，第二个时间窗口最开始的 10ms 内的 100 个请求都会被限流熔断。</p>
<p>滑动窗口法的<strong>缺陷</strong>：基于时间窗口的限流算法，<strong>只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Long&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 间隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeWindow</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 永续线程执行清理queue 任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待 间隔秒数-1 执行清理操作</span></span><br><span class="line">                    Thread.sleep((seconds - <span class="number">1</span>) * <span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                clean();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TimeWindow timeWindow = <span class="keyword">new</span> TimeWindow(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试3个线程</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">3</span>).forEach((i) -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    timeWindow.take();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌，并且添加时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = sizeOfValid();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) &#123;</span><br><span class="line">                System.err.println(<span class="string">"超限"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sizeOfValid() &gt; max) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"超限"</span>);</span><br><span class="line">                    System.err.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.queue.offer(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sizeOfValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Long&gt; it = queue.iterator();</span><br><span class="line">        Long ms = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = it.next();</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ms) &#123;</span><br><span class="line">                <span class="comment">// 在当前的统计时间范围内</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long c = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        Long tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((tl = queue.peek()) != <span class="keyword">null</span> &amp;&amp; tl &lt; c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"清理数据"</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-令牌桶法"><a class="markdownIt-Anchor" href="#四-令牌桶法"></a> 四、令牌桶法</h2>
<p>令牌桶算法的<strong>原理</strong>：</p>
<ol>
<li>接口限制 T 秒内最大访问次数为 N，则每隔 T/N 秒会放一个 token 到桶中</li>
<li>桶内最多存放 M 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 就会被丢弃</li>
<li>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则进行限流处理</li>
</ol>
<p>因为令牌桶存放了很多令牌，那么大量的突发请求会被执行，但是它不会出现临界问题，在令牌用完之后，令牌是以一个恒定的速率添加到令牌桶中的，因此不能再次发送大量突发请求。</p>
<p>规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。</p>
<p>【示例】Java 实现令牌桶算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 放入速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.min(total, nowSize + (now - time) * rate);</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> (nowSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶里没有token</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在token</span></span><br><span class="line">            nowSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【示例】基于 Redis Lua 令牌桶限流算法实现</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 令牌桶限流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 令牌的唯一标识</span></span><br><span class="line"><span class="keyword">local</span> bucketKey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_key = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 令牌桶的容量</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 请求令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> permits = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 令牌流入的速率</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> curr_mill_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> current_limit = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, bucketKey) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 获取上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_time = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, last_mill_request_key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 计算向桶里添加令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> last_mill_request_time == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">	<span class="comment">-- 令牌桶初始化</span></span><br><span class="line">	<span class="comment">-- 更新上次请求时间</span></span><br><span class="line">	redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">local</span> add_token_num = <span class="built_in">math</span>.<span class="built_in">floor</span>((curr_mill_time - last_mill_request_time) * rate)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> current_limit + add_token_num &gt; limit <span class="keyword">then</span></span><br><span class="line">    current_limit = limit</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	current_limit = current_limit + add_token_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">	redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>,bucketKey, current_limit)</span><br><span class="line"><span class="comment">-- 设置过期时间</span></span><br><span class="line">redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限流判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_limit - permits &lt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 达到限流大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到限流大小</span></span><br><span class="line">	current_limit = current_limit - permits</span><br><span class="line">	redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, bucketKey, current_limit)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">-- 更新上次请求的时间</span></span><br><span class="line">	redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="五-漏桶法"><a class="markdownIt-Anchor" href="#五-漏桶法"></a> 五、漏桶法</h2>
<p>相比于令牌桶算法，漏桶法对于取令牌的频率也有限制，要按照 T/N 的固定速率来取令牌 。</p>
<p>令牌桶算法和漏桶算法对流量的整形效果比较好，但是并不是整型效果好就越合适，对于没有提前预热的令牌桶，如果做否决式限流，会导致误杀很多请求。上述算法中当 n 比较小时，比如 50，间隔 20ms 才会向桶中放入一个令牌，而接口的访问在 1s 内可能随机性很强，这就会出现：尽管从曲线上看对最大访问频率的限制很有效，流量在细时间粒度上面都很平滑，但是误杀了很多本不应该拒绝的接口请求。</p>
<p>【示例】漏桶法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 水流出去的速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.max(<span class="number">0</span>, (nowSize - (now - time) * rate));</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> ((nowSize + <span class="number">1</span>) &lt; total) &#123;</span><br><span class="line">            nowSize++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-限流工具"><a class="markdownIt-Anchor" href="#六-限流工具"></a> 六、限流工具</h2>
<p>前面介绍了限流算法的基本原理和一些简单的实现。但在生产环境，我们一般应该使用更成熟的限流工具。</p>
<ul>
<li>Guava 的 <code>RateLimiter</code>：RateLimiter 基于漏桶算法，但它参考了令牌桶算法。具体用法可以参考：<a href="https://blog.csdn.net/forezp/article/details/100060686" target="_blank" rel="noopener">RateLimiter 基于漏桶算法，但它参考了令牌桶算法</a></li>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a>：经典的限流、熔断工具，很值得借鉴学习。注：官方已停止发布版本。</li>
<li><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a>：阿里的限流、熔断工具。</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://www.jianshu.com/p/76cc8ba5ca91" target="_blank" rel="noopener">谈谈限流算法的几种实现</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/huifer-how-to-limit-current.md" target="_blank" rel="noopener">如何限流？在工作中是怎么做的？说一下具体的实现？</a></li>
<li><a href="https://gongfukangee.github.io/2019/04/04/Limit/" target="_blank" rel="noopener">浅析限流算法</a></li>
<li><a href="https://blog.csdn.net/forezp/article/details/100060686" target="_blank" rel="noopener">RateLimiter 基于漏桶算法，但它参考了令牌桶算法</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/test-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/test-architecture/" class="post-title-link" itemprop="url">系统测试架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-10 17:00:00" itemprop="dateCreated datePublished" datetime="2019-12-10T17:00:00+08:00">2019-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/test-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/test-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统测试架构"><a class="markdownIt-Anchor" href="#系统测试架构"></a> 系统测试架构</h1>
<blockquote>
<p>软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p>
<p>现代软件开发项目中，分工明确，基本上都会有研发、测试、QA 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。</p>
<p>注意：</p>
<ul>
<li>为了方便，只有测试人员需要关注的测试点用【测试】标注；</li>
<li>而只有研发人员需要关注的测试点用【研发】标注；</li>
<li>都需要关注的测试点则不作标注。</li>
</ul>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB">测试方法分类</a>
<ul>
<li><a href="#%E4%BB%8E%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB">从测试设计方法分类</a></li>
<li><a href="#%E4%BB%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E7%9A%84%E5%88%86%E7%B1%BB">从测试的目的分类</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="测试方法分类"><a class="markdownIt-Anchor" href="#测试方法分类"></a> 测试方法分类</h2>
<h3 id="从测试设计方法分类"><a class="markdownIt-Anchor" href="#从测试设计方法分类"></a> 从测试设计方法分类</h3>
<ul>
<li><strong>黑盒测试【测试】</strong> - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。</li>
<li><strong>白盒测试【研发】</strong> - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</li>
<li><strong>灰盒测试</strong> - 介于黑盒和白盒之间。</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li>黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。</li>
<li>白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。</li>
<li>灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。</li>
</ul>
</blockquote>
<h3 id="从测试的目的分类"><a class="markdownIt-Anchor" href="#从测试的目的分类"></a> 从测试的目的分类</h3>
<h4 id="功能测试"><a class="markdownIt-Anchor" href="#功能测试"></a> 功能测试</h4>
<ul>
<li><strong>单元测试（Unit Test）</strong> - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】
<ul>
<li>常用技术：<a href="https://github.com/junit-team/junit4" target="_blank" rel="noopener"><strong>junit4</strong></a>、<a href="https://github.com/junit-team/junit5" target="_blank" rel="noopener"><strong>junit5</strong></a>、<a href="https://github.com/mockito/mockito" target="_blank" rel="noopener"><strong>mockito</strong></a>、<a href="https://github.com/joel-costigliola/assertj-core" target="_blank" rel="noopener"><strong>assertj-core</strong></a></li>
</ul>
</li>
<li><strong>功能测试（Functional Test）</strong> - 验证模块的功能。【测试】</li>
<li><strong>集成测试（Integration Test）</strong> - 验证几个互相有依赖关系的模块的功能。【测试】</li>
<li><strong>场景测试（Scenario Test）</strong>- 验证几个模块是否能完成一个用户场景。【测试】</li>
<li><strong>系统测试（System Test）</strong> - 对于整个系统功能的测试。【测试】</li>
<li><strong>Alpha 测试</strong> - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】</li>
<li><strong>Beta 测试</strong> - 也叫公测，是真实的用户在真实的环境中进行的测试。</li>
</ul>
<h4 id="非功能测试"><a class="markdownIt-Anchor" href="#非功能测试"></a> 非功能测试</h4>
<ul>
<li><strong>压力测试（Stress test）</strong> - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</li>
<li><strong>负载测试（Load test）</strong> - 测试软件在负载情况下能否正常工作</li>
<li><strong>性能测试（Performance test）</strong> - 测试软件的效能，是否提供满意的服务质量。
<ul>
<li>常用技术：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener"><strong>JMeter</strong></a>、JMH。</li>
</ul>
</li>
<li><strong>软件辅助功能测试（Accessibility test</strong>） - 测试软件是否向残疾用户提供足够的辅助功能</li>
<li><strong>本地化/全球化测试（Localization/Globalization</strong>）</li>
<li><strong>兼容性测试（Compatibility Test）</strong></li>
<li><strong>配置测试（Configuration Test）</strong> - 测试软件在各种配置下能否正常工作</li>
<li><strong>可用性测试（Usability Test）</strong> – 测试软件是否好用</li>
<li><strong>安全性测试（Security Test）</strong></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/02/20/2347016.html" target="_blank" rel="noopener">软件测试 (一) 软件测试方法大汇总</a></li>
<li><a href="https://www.xncoding.com/2018/01/07/java/jmh.html" target="_blank" rel="noopener">Java 微基准测试框架 JMH</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/distributed-storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/distributed-storage/" class="post-title-link" itemprop="url">分布式存储基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-16 20:54:00" itemprop="dateCreated datePublished" datetime="2019-10-16T20:54:00+08:00">2019-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/distributed-storage/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/distributed-storage/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式存储基本原理"><a class="markdownIt-Anchor" href="#分布式存储基本原理"></a> 分布式存储基本原理</h1>
<blockquote>
<p>分片（Sharding）的基本思想就要把一个数据库切分成多个部分，存储在不同的数据库(server)上，从而缓解单一数据库的性能问题。</p>
<p>分库分表一定是为了支撑 <strong>高并发、数据量大</strong> 两个问题的。</p>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">一、读写分离</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">为何要读写分离</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E7%90%86">读写分离的原理</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E9%97%AE%E9%A2%98">读写分离的问题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">二、分库分表</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">为何要分库分表</a></li>
<li><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8E%9F%E7%90%86">分库分表原理</a></li>
<li><a href="#%E8%BF%81%E7%A7%BB%E5%92%8C%E6%89%A9%E5%AE%B9">迁移和扩容</a></li>
<li><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98">分库分表的问题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E4%B8%AD%E9%97%B4%E4%BB%B6">三、中间件</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-读写分离"><a class="markdownIt-Anchor" href="#一-读写分离"></a> 一、读写分离</h2>
<p><strong>读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作</strong>。</p>
<h3 id="为何要读写分离"><a class="markdownIt-Anchor" href="#为何要读写分离"></a> 为何要读写分离</h3>
<ul>
<li><strong>有效减少锁竞争</strong> - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。</li>
<li><strong>提高查询吞吐量</strong> - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</li>
<li><strong>提升数据库可用性</strong> - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</li>
</ul>
<h3 id="读写分离的原理"><a class="markdownIt-Anchor" href="#读写分离的原理"></a> 读写分离的原理</h3>
<p>读写分离的实现是根据 SQL 语义分析，将读操作和写操作分别路由至主库与从库。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png" alt="读写分离" /></p>
<p>读写分离的基本实现是：</p>
<p><img src="http://dunwu.test.upcdn.net/cs/database/mysql/master-slave-proxy.png" alt="img" /></p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作。</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了全量数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
<li>主机会记录请求的二进制日志，然后推送给从库，从库解析并执行日志中的请求，完成主从复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。</li>
</ul>
<h3 id="读写分离的问题"><a class="markdownIt-Anchor" href="#读写分离的问题"></a> 读写分离的问题</h3>
<p>读写分离存在两个问题：<strong>数据一致性</strong>和<strong>分发机制</strong>。</p>
<h4 id="数据一致性"><a class="markdownIt-Anchor" href="#数据一致性"></a> 数据一致性</h4>
<p>读写分离产生了主库与从库之间的数据一致性的问题。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png" alt="数据分片 + 读写分离" /></p>
<h4 id="分发机制"><a class="markdownIt-Anchor" href="#分发机制"></a> 分发机制</h4>
<p>数据库读写分离后，一个 SQL 请求具体分发到哪个数据库节点？一般有两种分发方式：客户端分发和中间件代理分发。</p>
<p>客户端分发，是基于程序代码，自行控制数据分发到哪个数据库节点。更细一点来说，一般程序中建立多个数据库的连接，根据一定的算法，选择合适的连接去发起 SQL 请求。这种方式也被称为客户端中间件，代表有：jdbc-sharding。</p>
<p>中间件代理分发，指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。代表有：Mycat。</p>
<h2 id="二-分库分表"><a class="markdownIt-Anchor" href="#二-分库分表"></a> 二、分库分表</h2>
<h3 id="为何要分库分表"><a class="markdownIt-Anchor" href="#为何要分库分表"></a> 为何要分库分表</h3>
<p>分库分表主要基于以下理由：</p>
<ul>
<li><strong>并发连接</strong> - 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。</li>
<li><strong>磁盘容量</strong> - 磁盘容量占满，会导致服务器不可用。</li>
<li><strong>SQL 性能</strong> - 单表数据量过大，会导致 SQL 执行效率低下。一般，单表有 200 万条数据，就可以考虑分表了。</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>分库分表前</th>
<th>分库分表后</th>
</tr>
</thead>
<tbody>
<tr>
<td>并发支撑情况</td>
<td>MySQL 单机部署，扛不住高并发</td>
<td>MySQL 从单机到多机，能承受的并发增加了多倍</td>
</tr>
<tr>
<td>磁盘使用情况</td>
<td>MySQL 单机磁盘容量几乎撑满</td>
<td>拆分为多个库，数据库服务器磁盘使用率大大降低</td>
</tr>
<tr>
<td>SQL 执行性能</td>
<td>单表数据量太大，SQL 越跑越慢</td>
<td>单表数据量减少，SQL 执行效率明显提升</td>
</tr>
</tbody>
</table>
<h3 id="分库分表原理"><a class="markdownIt-Anchor" href="#分库分表原理"></a> 分库分表原理</h3>
<p><strong>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果</strong>。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p>
<p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。</p>
<h4 id="垂直分片"><a class="markdownIt-Anchor" href="#垂直分片"></a> 垂直分片</h4>
<p>垂直分片有两种拆分考量：业务拆分和访问频率拆分</p>
<p>（1）业务拆分</p>
<blockquote>
<p>业务拆分的核心理念是<strong>专库专用</strong>。</p>
</blockquote>
<p>在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是<strong>按照业务将表进行归类，分布到不同的数据库中</strong>，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。</p>
<p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。<strong>垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理</strong>。</p>
<p>（2）访问频率拆分</p>
<blockquote>
<p>访问频率拆分，是 <strong>把一个有很多字段的表给拆分成多个表，或者是多个库上去</strong>。一般来说，会 <strong>将较少的、访问频率较高的字段放到一个表中</strong>，然后 <strong>将较多的、访问频率较低的字段放到另外一个表中</strong>。因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>
</blockquote>
<p><img src="http://dunwu.test.upcdn.net/snap/image-20200114211639899.png" alt="image-20200114211639899" /></p>
<p>一般来说，满足下面的条件就可以考虑扩容了：</p>
<ul>
<li>Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大。</li>
<li>单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。</li>
</ul>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<h4 id="水平分片"><a class="markdownIt-Anchor" href="#水平分片"></a> 水平分片</h4>
<blockquote>
<p><strong>水平拆分</strong> 又称为 <strong>Sharding</strong>，它是将同一个表中的记录拆分到多个结构相同的表中。当 <strong>单表数据量太大</strong> 时，会极大影响 <strong>SQL 执行的性能</strong> 。分表是将原来一张表的数据分布到数据库集群的不同节点上，从而缓解单点的压力。</p>
</blockquote>
<p>相对于垂直分片，水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）。</p>
<p>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/image-20200114211203589.png" alt="image-20200114211203589" /></p>
<p>一般来说，<strong>单表有 200 万条数据</strong> 的时候，性能就会相对差一些了，需要考虑分表了。但是，这也要视具体情况而定，可能是 100 万条，也可能是 500 万条，SQL 越复杂，就最好让单表行数越少。</p>
<p>读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。</p>
<h4 id="分库分表策略"><a class="markdownIt-Anchor" href="#分库分表策略"></a> 分库分表策略</h4>
<p><img src="http://dunwu.test.upcdn.net/snap/20200608091832.png" alt="img" /></p>
<p>分库分表策略主要有两种：</p>
<ul>
<li>根据数值范围划分</li>
<li>根据 Hash 划分</li>
</ul>
<h5 id="数值范围路由"><a class="markdownIt-Anchor" href="#数值范围路由"></a> 数值范围路由</h5>
<p>数值范围路由，就是根据 ID、时间范围 这类具有排序性的字段来进行划分。例如：用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。</p>
<p>按这种策略划分出来的数据，具有数据连续性。</p>
<p>优点：数据迁移很简单。</p>
<p>缺点：容易产生热点问题，大量的流量都打在最新的数据上了。</p>
<h5 id="hash-路由"><a class="markdownIt-Anchor" href="#hash-路由"></a> Hash 路由</h5>
<p><img src="C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200608092034118.png" alt="image-20200608092034118" /></p>
<p>典型的 Hash 路由，如根据数值取模，当需要扩容时，一般以 2 的幂次方进行扩容（这样，扩容时迁移的数据量会小一些）。例如：用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。</p>
<p>一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p>
<p>优点：数据离散分布，不存在热点问题。</p>
<p>缺点：数据迁移、扩容麻烦（之前的数据需要重新计算 hash 值重新分配到不同的库或表）。当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p>
<h5 id="路由表"><a class="markdownIt-Anchor" href="#路由表"></a> 路由表</h5>
<p>这种策略，就是用一张独立的表记录路由信息。</p>
<p>优点：简单、灵活，尤其是在扩容、迁移时，只需要迁移指定的数据，然后修改路由表即可。</p>
<p>缺点：每次查询，必须先查路由表，增加了 IO 开销。并且，如果路由表本身太大，也会面临性能瓶颈，如果想对路由表再做分库分表，将出现死循环式的路由算法选择问题。</p>
<h3 id="迁移和扩容"><a class="markdownIt-Anchor" href="#迁移和扩容"></a> 迁移和扩容</h3>
<h4 id="停机迁移扩容不推荐"><a class="markdownIt-Anchor" href="#停机迁移扩容不推荐"></a> 停机迁移/扩容（不推荐）</h4>
<p>停机迁移/扩容是最暴力、最简单的迁移、扩容方案。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200601114836.png" alt="img" /></p>
<h5 id="停机迁移扩容流程"><a class="markdownIt-Anchor" href="#停机迁移扩容流程"></a> 停机迁移/扩容流程</h5>
<p>（0）预估停服时间，发布停服公告。</p>
<p>（1）停服，不允许数据访问。</p>
<p>（2）编写临时的数据导入程序，从老数据库中读取数据。</p>
<p>（3）将数据写入中间件。</p>
<p>（4）中间件根据分片规则，将数据分发到分库（分表）中。</p>
<p>（5）应用程序修改配置，重启。</p>
<h5 id="停机迁移扩容方案分析"><a class="markdownIt-Anchor" href="#停机迁移扩容方案分析"></a> 停机迁移/扩容方案分析</h5>
<p>优点：简单、没有数据一致性问题。</p>
<p>缺点：如果老的数据库数据量很大，则停机处理时间可能很久。比如老的数据库是已经分库分表的数据库群，数据量可能达到亿级，导入数据可能就要花费几小时。如果中间过程中出现问题，就容易引发重大事故。</p>
<p>点评：综上，这种方案代价太高，不可取。</p>
<h4 id="双写迁移"><a class="markdownIt-Anchor" href="#双写迁移"></a> 双写迁移</h4>
<p><img src="http://dunwu.test.upcdn.net/snap/20200601135751.png" alt="img" /></p>
<h5 id="双写迁移流程"><a class="markdownIt-Anchor" href="#双写迁移流程"></a> 双写迁移流程</h5>
<p>（1）修改应用程序配置，将数据同时写入老数据库和中间件。这就是所谓的<strong>双写</strong>，同时写俩库，老库和新库。</p>
<p>（2）编写临时程序，读取老数据库。</p>
<p>（3）将数据写入中间件。如果数据不存在，直接写入；如果数据存在，比较时间戳，只允许新数据覆盖老数据。</p>
<p>（4）导入数据后，有可能数据还是存在不一致，那么就对数据进行校验，比对新老库的每条数据。如果存在差异，针对差异数据，执行（3）。循环（3）、（4）步骤，直至数据完全一致。</p>
<p>（5）修改应用程序配置，将数据只写入中间件。</p>
<p>（6）中间件根据分片规则，将数据分发到分库（分表）中。</p>
<h4 id="主从升级"><a class="markdownIt-Anchor" href="#主从升级"></a> 主从升级</h4>
<p>生产环境的数据库，为了保证高可用，一般会采用主备架构。主库支持读写操作，从库支持读操作。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200601121215.png" alt="img" /></p>
<p>由于主备节点数据一致，所以将从库升级为主节点，并修改分片配置，将从节点作为分库之一，就实现了扩容。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200601121400.png" alt="img" /></p>
<h5 id="升级从库的流程"><a class="markdownIt-Anchor" href="#升级从库的流程"></a> 升级从库的流程</h5>
<p>（1）解除主从关系，从库升级为主库。</p>
<p>（2）应用程序，修改配置，读写通过中间件。</p>
<p>（3）分库分表中间，修改分片配置。将数据按照新的规则分发。</p>
<p>（4）编写临时程序，清理冗余数据。比如：原来是一个单库，数据量为 400 万。从节点升级为分库之一后，每个分库都有 400 万数据，其中 200 万是冗余数据。清理完后，进行数据校验。</p>
<p>（5）为每个分库添加新的从库，保证高可用。</p>
<h5 id="升级从库方案分析"><a class="markdownIt-Anchor" href="#升级从库方案分析"></a> 升级从库方案分析</h5>
<p>优点：不需要停机，无需数据迁移。</p>
<p>缺点：</p>
<h3 id="分库分表的问题"><a class="markdownIt-Anchor" href="#分库分表的问题"></a> 分库分表的问题</h3>
<h4 id="分布式-id-问题"><a class="markdownIt-Anchor" href="#分布式-id-问题"></a> 分布式 ID 问题</h4>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。</p>
<blockquote>
<p>分布式 ID 的解决方案详见：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-id.md" target="_blank" rel="noopener">分布式 ID</a></p>
</blockquote>
<h4 id="分布式事务问题"><a class="markdownIt-Anchor" href="#分布式事务问题"></a> 分布式事务问题</h4>
<p>跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</p>
<blockquote>
<p>分布式事务的解决方案详见：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md" target="_blank" rel="noopener">分布式事务</a></p>
</blockquote>
<h4 id="跨节点-join-和聚合"><a class="markdownIt-Anchor" href="#跨节点-join-和聚合"></a> 跨节点 Join 和聚合</h4>
<p>分库分表后，无法直接跨节点 <code>join</code> 、<code>count</code>、<code>order by</code>、<code>group by</code> 以及聚合。</p>
<p>针对这类问题，普遍做法是<strong>二次查询</strong>。</p>
<p>在第一次查询时，获取各个节点上的结果。</p>
<p>在程序中将这些结果进行合并、筛选。</p>
<h4 id="跨分片的排序分页"><a class="markdownIt-Anchor" href="#跨分片的排序分页"></a> 跨分片的排序分页</h4>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-925381b9a478c8df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p>
<p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-9a7cfbdb95bb9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p>
<p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p>
<p>那如何解决分库情况下的分页问题呢？有以下几种办法：</p>
<p>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p>
<p>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p>
<p>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p>
<h2 id="三-中间件"><a class="markdownIt-Anchor" href="#三-中间件"></a> 三、中间件</h2>
<p>国内常见分库分表中间件：</p>
<ul>
<li><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">Cobar</a> - 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 cobar 集群，cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</li>
<li><a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL</a> - 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</li>
<li><a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas</a> - 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">sharding-jdbc</a> - 当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</li>
<li><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">Mycat</a> - 基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。</li>
</ul>
<p>技术选型建议：</p>
<p>建议使用的是 sharding-jdbc 和 mycat。</p>
<ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">sharding-jdbc</a> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> sharding-jdbc 的依赖。其本质上通过配置多数据源，然后根据设定的分库分表策略，计算路由，将请求发送到计算得到的节点上。</li>
<li><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">Mycat</a> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</li>
</ul>
<p>通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 mycat，然后大量项目直接透明使用即可。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">ShardingSphere 官方文档</a></li>
<li><a href="https://juejin.im/post/5bf778ef5188251b8a26ed8b" target="_blank" rel="noopener">“分库分表&quot; ？选型和流程要慎重，否则会失控</a></li>
<li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a></li>
<li><a href="https://juejin.im/post/5d4b6dc1f265da03c1288332" target="_blank" rel="noopener">一次难得的分库分表实践</a></li>
<li><a href="https://www.cnblogs.com/barrywxx/p/11532122.html" target="_blank" rel="noopener">分库分表平滑扩容</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/distributed-id/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/distributed-id/" class="post-title-link" itemprop="url">分布式 ID 基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-24 11:55:00" itemprop="dateCreated datePublished" datetime="2019-07-24T11:55:00+08:00">2019-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/distributed-id/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/distributed-id/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式-id-基本原理"><a class="markdownIt-Anchor" href="#分布式-id-基本原理"></a> 分布式 ID 基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。</p>
<p>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p>
<p>为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F-id-%E7%AE%80%E4%BB%8B">一、分布式 ID 简介</a></li>
<li><a href="#%E4%BA%8Cuuid">二、UUID</a>
<ul>
<li><a href="#uuid-%E7%9A%84%E4%BC%98%E7%82%B9">UUID 的优点</a></li>
<li><a href="#uuid-%E7%9A%84%E7%BC%BA%E7%82%B9">UUID 的缺点</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%88%A9%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%AD%98%E5%82%A8%E7%94%9F%E6%88%90%E9%94%AE">三、利用第三方存储生成键</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake">四、雪花算法（Snowflake）</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">基本原理</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-1">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-1">缺点</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1">适用场景</a></li>
<li><a href="#%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8">防止时钟回拨</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94leaf">五、Leaf</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1">基本原理</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-2">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-2">缺点</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2">适用场景</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-分布式-id-简介"><a class="markdownIt-Anchor" href="#一-分布式-id-简介"></a> 一、分布式 ID 简介</h2>
<p>首先，分布式 ID 应该具备哪些特性呢？</p>
<ol>
<li><strong>全局唯一性</strong> - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>趋势递增</strong> - 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li><strong>单调递增</strong> - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li>
<li><strong>信息安全</strong> - 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ol>
<h2 id="二-uuid"><a class="markdownIt-Anchor" href="#二-uuid"></a> 二、UUID</h2>
<p>UUID 是最简单的分布式 ID 方案。</p>
<p>UUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。</p>
<p>UUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:</p>
<ul>
<li>random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>
<ul>
<li>time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">getTimeBasedUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() * <span class="number">10000L</span> + <span class="number">122192928000000000L</span> + (<span class="keyword">long</span>)(COUNT.incrementAndGet() % <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">long</span> timeLow = (time &amp; <span class="number">4294967295L</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">long</span> timeMid = (time &amp; <span class="number">281470681743360L</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span> timeHi = (time &amp; <span class="number">1152640029630136320L</span>) &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">long</span> most = timeLow | timeMid | <span class="number">4096L</span> | timeHi;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(most, LEAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>DCE security - DCE 安全的 UUID。</p>
</li>
<li>
<p>name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。</p>
</li>
</ul>
<h3 id="uuid-的优点"><a class="markdownIt-Anchor" href="#uuid-的优点"></a> UUID 的优点</h3>
<ul>
<li>通过本地生成，没有经过网络 I/O，性能较快。</li>
</ul>
<h3 id="uuid-的缺点"><a class="markdownIt-Anchor" href="#uuid-的缺点"></a> UUID 的缺点</h3>
<ul>
<li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li>
<li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
<li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3>
<p>UUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 <code>UuidPatternConverter</code> 中加入了 UUID 来标识每一条日志。</p>
<h2 id="三-利用第三方存储生成键"><a class="markdownIt-Anchor" href="#三-利用第三方存储生成键"></a> 三、利用第三方存储生成键</h2>
<p>提到自增键，最先想到的肯定是直接使用数据库自增键。<em>各数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等</em>。</p>
<p>当然，也可以考虑是用 Redis 这样的 Nosql，甚至 ZooKeeper 去生成键</p>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ul>
<li>非常简单，利用现有的功能实现，成本小</li>
<li>有序递增</li>
<li>方便排序和分页</li>
</ul>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ul>
<li>强依赖第三方存储，如果第三方存储非高可用系统，若出现丢失数据的情况，就可能出现重复生成 ID 的问题。</li>
<li>生成 ID 性能瓶颈依赖于第三方存储的性能。</li>
<li>增加了对第三方存储运维的成本。</li>
</ul>
<h2 id="四-雪花算法snowflake"><a class="markdownIt-Anchor" href="#四-雪花算法snowflake"></a> 四、雪花算法（Snowflake）</h2>
<p>雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，<strong>它会生成一个 <code>64 bit</code> 的整数</strong>，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。</p>
<p>在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p>
<h3 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3>
<h4 id="键的组成"><a class="markdownIt-Anchor" href="#键的组成"></a> 键的组成</h4>
<p>使用<strong>雪花算法生成的主键，二进制表示形式包含 4 部分</strong>，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p>
<ul>
<li><strong>符号位(1bit)</strong></li>
</ul>
<p>预留的符号位，恒为零。</p>
<ul>
<li><strong>时间戳位(41bit)</strong></li>
</ul>
<p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<p>结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p>
<ul>
<li><strong>工作进程位(10bit)</strong></li>
</ul>
<p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p>
<ul>
<li><strong>序列号位(12bit)</strong></li>
</ul>
<p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p>
<p>雪花算法主键的详细结构见下图：</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png" alt="雪花算法" /></p>
<h4 id="时钟回拨"><a class="markdownIt-Anchor" href="#时钟回拨"></a> 时钟回拨</h4>
<p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p>
<h4 id="灵活定制"><a class="markdownIt-Anchor" href="#灵活定制"></a> 灵活定制</h4>
<p>上面只是一个将 <code>64bit</code> 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前 QPS10 万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器 10 台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p>
<p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
<ul>
<li>生成的 ID 都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li>
<li>可以根据自身业务特性分配 bit 位，非常灵活。</li>
</ul>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
<h3 id="适用场景-2"><a class="markdownIt-Anchor" href="#适用场景-2"></a> 适用场景</h3>
<p>当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p>
<h3 id="防止时钟回拨"><a class="markdownIt-Anchor" href="#防止时钟回拨"></a> 防止时钟回拨</h3>
<p>雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。</p>
<p>我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。</p>
<p>用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:</p>
<ul>
<li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:
<ul>
<li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li>
<li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ul>
</li>
</ul>
<h2 id="五-leaf"><a class="markdownIt-Anchor" href="#五-leaf"></a> 五、Leaf</h2>
<blockquote>
<p>美团提供了一种分布式 ID 解决方案 Leaf，其本质可以视为数据库分段+服务缓存 ID。</p>
<p>详情可以参考 <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></p>
</blockquote>
<h3 id="基本原理-2"><a class="markdownIt-Anchor" href="#基本原理-2"></a> 基本原理</h3>
<p>使用数据库生成 ID，但是做了如下改进：</p>
<p>原方案每次获取 ID 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>重要字段说明：</p>
<ul>
<li><code>biz_tag</code> 用来区分业务</li>
<li><code>max_id</code> 表示该 <code>biz_tag</code> 目前所被分配的 ID 号段的最大值</li>
<li><code>step</code> 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 <code>step</code> 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。</li>
</ul>
<p>大致架构如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5e4ff128.png" alt="image" /></p>
<p>test_tag 在第一台 Leaf 机器上是 <code>1~1000</code> 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 <code>3001~4000</code>。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id=max_id+step <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>
<h3 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点</h3>
<ul>
<li>比数据库自增键性能高</li>
<li>能保证键趋势递增。</li>
<li>如果数据库宕机，由于 proxServer 有缓存，依然可以坚持一段时间。</li>
</ul>
<h3 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h3>
<ul>
<li>和主键递增一样，容易被人猜测。</li>
<li>数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。</li>
</ul>
<h3 id="适用场景-3"><a class="markdownIt-Anchor" href="#适用场景-3"></a> 适用场景</h3>
<p>需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。</p>
<p>当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">百度分布式 ID</a></li>
<li><a href="https://juejin.im/post/5bb0217ef265da0ac2567b42" target="_blank" rel="noopener">如果再有人问你分布式 ID，这篇文章丢给他</a></li>
<li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">理解分布式 id 生成算法 SnowFlake</a></li>
<li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></li>
<li><a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">UUID 规范</a></li>
<li><a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/" target="_blank" rel="noopener">ShardingSphere 分布式主键</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/mq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/mq/" class="post-title-link" itemprop="url">消息队列基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2019-07-05T15:11:00+08:00">2019-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/mq/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/mq/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列基本原理"><a class="markdownIt-Anchor" href="#消息队列基本原理"></a> 消息队列基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>消息队列（Message Queue，简称 MQ）技术是分布式应用间交换信息的一种技术。</p>
<p>消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p>
<p>注意：<em>为了简便，下文中除了文章标题，一律使用 MQ 简称</em>。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E4%B8%BA%E4%BD%95%E7%94%A8-mq">一、为何用 MQ</a>
<ul>
<li><a href="#%E8%A7%A3%E8%80%A6">解耦</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5">异步</a></li>
<li><a href="#%E5%89%8A%E5%B3%B0">削峰</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Cmq-%E7%9A%84%E9%97%AE%E9%A2%98">二、MQ 的问题</a>
<ul>
<li><a href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9">重复消费</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1">消息丢失</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7">消息的顺序性</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B">消息积压</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89mq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">三、MQ 的高可用</a>
<ul>
<li><a href="#kafka-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">Kafka 的高可用</a></li>
</ul>
</li>
<li><a href="#mq-%E7%9A%84%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F">MQ 的通信模式</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8-mq-%E5%AF%B9%E6%AF%94">常用 MQ 对比</a></li>
<li><a href="#jms">JMS</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">消息模型</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9">消息消费</a></li>
<li><a href="#jms-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">JMS 编程模型</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-为何用-mq"><a class="markdownIt-Anchor" href="#一-为何用-mq"></a> 一、为何用 MQ</h2>
<p>MQ 比较核心的优点有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<h3 id="解耦"><a class="markdownIt-Anchor" href="#解耦"></a> 解耦</h3>
<p>不同系统如果要建立通信，传统的做法是：调用接口。</p>
<p>如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_1.png" alt="img" /></p>
<p>如果使用 MQ，系统间的通信只需要通过发布/订阅（Pub/Sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 <strong>解耦</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_2.png" alt="img" /></p>
<h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3>
<p>假设这样一个场景，用户向系统 A 发起请求，系统 A 处理计算只需要 10 ms，然后通知系统 BCD 写库，系统 BCD 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_3.png" alt="img" /></p>
<p>如果使用 MQ，系统 A 接到请求后，耗时 10ms 处理计算，然后向系统 BCD 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 BCD 的写库操作，只要自行消费 MQ 后处理即可，用户无需关注。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_4.png" alt="img" /></p>
<h3 id="削峰"><a class="markdownIt-Anchor" href="#削峰"></a> 削峰</h3>
<p>假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_5.png" alt="img" /></p>
<p>如果使用 MQ，每秒写入 10000 条请求，但是系统 A 每秒只从 MQ 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 MQ 中。只要高峰期一过，系统 A 就会很快把积压的消息给处理掉。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_6.png" alt="img" /></p>
<h2 id="二-mq-的问题"><a class="markdownIt-Anchor" href="#二-mq-的问题"></a> 二、MQ 的问题</h2>
<p>凡事有利有弊，使用 MQ 给系统带来很多好处，也会付出一定的代价。</p>
<p>它引入了以下问题：</p>
<ul>
<li><strong>系统可用性降低</strong> - 引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。因此，MQ 要保证是高可用的，详情参考：<a href="#MQ-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">MQ 的高可用</a></li>
<li><strong>系统复杂度提高</strong> - 使用 MQ，需要关注一些新的问题：
<ul>
<li>如何保证消息没有重复消费？</li>
<li>如何处理消息丢失的问题？</li>
<li>如何保证消息传递的顺序性？</li>
<li>如何处理大量消息积压的问题？</li>
</ul>
</li>
<li><strong>一致性问题</strong> - 假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</li>
</ul>
<h3 id="重复消费"><a class="markdownIt-Anchor" href="#重复消费"></a> 重复消费</h3>
<p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p>
<p>必须先明确产生重复消费的原因，才能对症下药。</p>
<h4 id="重复消费问题原因"><a class="markdownIt-Anchor" href="#重复消费问题原因"></a> 重复消费问题原因</h4>
<p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p>
<p>以 Kafka 举例：Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。</p>
<p><img src="http://kafka.apachecn.org/10/images/log_consumer.png" alt="img" /></p>
<p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p>
<p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-75abe308f9cf21f8.png" alt="img" /></p>
<h4 id="重复消费解决方案"><a class="markdownIt-Anchor" href="#重复消费解决方案"></a> 重复消费解决方案</h4>
<p>应对重复消费问题，就要通过幂等性来解决。</p>
<p>这个问题可以从业务层面来解决。</p>
<p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p>
<ul>
<li>如果是写数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li>
<li>如果是写 Redis，set 操作，由于天然具有幂等性，大可放心；</li>
<li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li>
</ul>
<h3 id="消息丢失"><a class="markdownIt-Anchor" href="#消息丢失"></a> 消息丢失</h3>
<p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有：</p>
<ul>
<li>Kafka Server 丢失数据</li>
<li>消费方丢失数据</li>
<li>生产方丢失数据</li>
</ul>
<h4 id="消费方丢失数据"><a class="markdownIt-Anchor" href="#消费方丢失数据"></a> 消费方丢失数据</h4>
<p>唯一可能导致消费方丢失数据的情况，就是：消费方设置了<strong>自动提交 Offset</strong>。设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p>
<p>解决方法就是：消费方关闭自动提交 Offset，处理完消息后<strong>手动提交 Offset</strong>。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p>
<h4 id="kafka-丢失数据"><a class="markdownIt-Anchor" href="#kafka-丢失数据"></a> Kafka 丢失数据</h4>
<p>当 Kafka 某个 Broker 宕机，需要重新选举 Partition 的 Leader。若此时其他的 Follower 尚未同步 Leader 的数据，那么新选某个 Follower 为 Leader 后，就丢失了部分数据。</p>
<p>为此，一般要求至少设置 4 个参数：</p>
<ul>
<li>给 Topic 设置 <code>replication.factor</code> 参数 - 这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数 - 这个值必须大于 1，这是要求一个 Leader 需要和至少一个 Follower 保持通信，这样才能确保 Leader 挂了还有替补。</li>
<li>在 Producer 端设置 <code>acks=all</code> - 这意味着：要求每条数据，必须是<strong>写入所有 replica 之后，才能认为写入成功了</strong>。</li>
<li>在 Producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思） - 这意味着<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<h4 id="生产方丢失数据"><a class="markdownIt-Anchor" href="#生产方丢失数据"></a> 生产方丢失数据</h4>
<p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p>
<p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h3 id="消息的顺序性"><a class="markdownIt-Anchor" href="#消息的顺序性"></a> 消息的顺序性</h3>
<blockquote>
<p>以 Kafka 为例</p>
</blockquote>
<p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p>
<p>方案一</p>
<p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p>
<p>方案二</p>
<ul>
<li>写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。</li>
<li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：
<ul>
<li>消费方维护 N 个缓存队列，具有相同 ID 的数据都写入同一个队列中；</li>
<li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_7.png" alt="img" /></p>
<h3 id="消息积压"><a class="markdownIt-Anchor" href="#消息积压"></a> 消息积压</h3>
<p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p>
<p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li>
<li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li>
<li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li>
<li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="三-mq-的高可用"><a class="markdownIt-Anchor" href="#三-mq-的高可用"></a> 三、MQ 的高可用</h2>
<p>不同 MQ 实现高可用的原理各不相同。因为 Kafka 比较具有代表性，所以这里以 Kafka 为例。</p>
<h3 id="kafka-的高可用"><a class="markdownIt-Anchor" href="#kafka-的高可用"></a> Kafka 的高可用</h3>
<h4 id="kafka-的核心概念"><a class="markdownIt-Anchor" href="#kafka-的核心概念"></a> Kafka 的核心概念</h4>
<p>了解 Kafka，必须先了解 Kafka 的核心概念：</p>
<ul>
<li>
<p><strong>Broker</strong> - Kafka 集群包含一个或多个节点，这种节点被称为 Broker。</p>
</li>
<li>
<p><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 Topic， Kafka 集群都会维持一个分区日志。</p>
</li>
<li>
<p><strong>Partition</strong> - 了提高 Kafka 的吞吐率，每个 Topic 包含一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。</p>
<ul>
<li>Kafka 日志的分区（Partition）分布在 Kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-cluster-roles.png" alt="img" /></p>
<h4 id="kafka-的副本机制"><a class="markdownIt-Anchor" href="#kafka-的副本机制"></a> Kafka 的副本机制</h4>
<p>Kafka 是如何实现高可用的呢？</p>
<p>Kafka 在 0.8 以前的版本中，如果一个 Broker 宕机了，其上面的 Partition 都不能用了，这自然不是高可用的。</p>
<p>为了实现高可用，Kafka 引入了复制功能。</p>
<p>简单来说，就是副本机制（ Replicate ）。</p>
<p><strong>每个 Partition 都有一个 Leader，零个或多个 Follower</strong>。Leader 和 Follower 都是 Broker，每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。</p>
<ul>
<li><strong>Leader 处理一切对 Partition （分区）的读写请求</strong>；</li>
<li><strong>而 Follower 只需被动的同步 Leader 上的数据</strong>。</li>
</ul>
<p><strong>同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份</strong>，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-replication.png" alt="img" /></p>
<blockquote>
<p>FAQ</p>
<p>问：为什么让 Leader 处理一切对对 Partition （分区）的读写请求？</p>
<p>答：因为如果允许所有 Broker 都可以处理读写请求，就可能产生数据一致性问题。</p>
</blockquote>
<h4 id="kafka-选举-leader"><a class="markdownIt-Anchor" href="#kafka-选举-leader"></a> Kafka 选举 Leader</h4>
<p>由上文可知，Partition 在多个 Broker 上存在副本。</p>
<p>如果某个 Follower 宕机，啥事儿没有，正常工作。</p>
<p>如果 Leader 宕机了，会从 Follower 中<strong>重新选举</strong>一个新的 Leader。</p>
<h2 id="mq-的通信模式"><a class="markdownIt-Anchor" href="#mq-的通信模式"></a> MQ 的通信模式</h2>
<p>MQ 可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读取。通过 MQ，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。</p>
<ul>
<li><strong>点对点</strong> - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li>
<li><strong>多点广播</strong> - MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li>
<li><strong>发布/订阅 (Publish/Subscribe)</strong> - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。</li>
<li><strong>集群 (Cluster)</strong> - 为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li>
</ul>
<h2 id="常用-mq-对比"><a class="markdownIt-Anchor" href="#常用-mq-对比"></a> 常用 MQ 对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行流式计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody>
</table>
<p>综上，各种对比之后，有如下建议：</p>
<ul>
<li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li>
<li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="jms"><a class="markdownIt-Anchor" href="#jms"></a> JMS</h2>
<p>谈 MQ 就不得不提一下 JMS 。</p>
<p><strong>JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息</strong>。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>在 EJB 架构中，有消息 bean 可以无缝的与 JM 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h3 id="消息模型"><a class="markdownIt-Anchor" href="#消息模型"></a> 消息模型</h3>
<p>在 JMS 标准中，有两种消息模型：</p>
<ul>
<li>P2P(Point to Point)</li>
<li>Pub/Sub(Publish/Subscribe)</li>
</ul>
<h4 id="p2p-模式"><a class="markdownIt-Anchor" href="#p2p-模式"></a> P2P 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-2adc66e2367cd2c2.png"/></div>
P2P 模式包含三个角色：MQ（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。
<p>P2P 的特点</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在 MQ 中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功</li>
</ul>
<p>如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。</p>
<h4 id="pubsub-模式"><a class="markdownIt-Anchor" href="#pubsub-模式"></a> Pub/sub 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-12afe9581da889ea.png"/></div>
包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。
<p>Pub/Sub 的特点</p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态。</li>
</ul>
<p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。</p>
<h3 id="消息消费"><a class="markdownIt-Anchor" href="#消息消费"></a> 消息消费</h3>
<p>在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。</p>
<ul>
<li><strong>同步</strong> - 订阅者或接收者通过 <code>receive</code> 方法来接收消息，<code>receive</code> 方法在接收到消息之前（或超时之前）将一直阻塞；</li>
<li><strong>异步</strong> - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 <code>onMessage</code> 方法。</li>
</ul>
<p><code>JNDI</code> - Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p>
<p>JNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。</p>
<h3 id="jms-编程模型"><a class="markdownIt-Anchor" href="#jms-编程模型"></a> JMS 编程模型</h3>
<h4 id="connectionfactory"><a class="markdownIt-Anchor" href="#connectionfactory"></a> ConnectionFactory</h4>
<p>创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。</p>
<h4 id="destination"><a class="markdownIt-Anchor" href="#destination"></a> Destination</h4>
<p>Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。</p>
<h4 id="3-connection"><a class="markdownIt-Anchor" href="#3-connection"></a> (3) Connection</h4>
<p>Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。</p>
<h4 id="4-session"><a class="markdownIt-Anchor" href="#4-session"></a> (4) Session</h4>
<p>Session 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。</p>
<h4 id="消息的生产者"><a class="markdownIt-Anchor" href="#消息的生产者"></a> 消息的生产者</h4>
<p>消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。</p>
<h4 id="消息消费者"><a class="markdownIt-Anchor" href="#消息消费者"></a> 消息消费者</h4>
<p>消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。</p>
<h4 id="messagelistener"><a class="markdownIt-Anchor" href="#messagelistener"></a> MessageListener</h4>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。</p>
<p>深入学习 JMS 对掌握 JAVA 架构，EJB 架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5155983.html" target="_blank" rel="noopener">大型网站架构系列：分布式 MQ（一）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5156155.html" target="_blank" rel="noopener">大型网站架构系列：MQ（二）</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放 MQ(RocketMQ)的原理与实践</a></li>
<li><a href="https://juejin.im/entry/5a0abfb5f265da43062a4a91" target="_blank" rel="noopener">阿里 RocketMQ 优势对比</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-interview.md" target="_blank" rel="noopener">advanced-java 之 MQ</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/cache/" class="post-title-link" itemprop="url">缓存基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-27 15:36:00" itemprop="dateCreated datePublished" datetime="2019-06-27T15:36:00+08:00">2019-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/cache/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/cache/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓存基本原理"><a class="markdownIt-Anchor" href="#缓存基本原理"></a> 缓存基本原理</h1>
<blockquote>
<p>缓存是一种利用空间换时间的设计，其目标就是<strong>更快</strong>、<strong>更近</strong>。</p>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<p><img src="http://dunwu.test.upcdn.net/snap/20200710163555.png" alt="img" /></p>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E7%BC%93%E5%AD%98%E7%AE%80%E4%BB%8B">一、缓存简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98">什么是缓存</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E7%BC%93%E5%AD%98">何时需要缓存</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">缓存的基本原理</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">缓存淘汰策略</a></li>
<li><a href="#jsr-107">JSR 107</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">二、缓存的分类</a>
<ul>
<li><a href="#http-%E7%BC%93%E5%AD%98">HTTP 缓存</a></li>
<li><a href="#cdn-%E7%BC%93%E5%AD%98">CDN 缓存</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98">反向代理缓存</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">三、进程内缓存</a>
<ul>
<li><a href="#concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="#lruhashmap">LRUHashMap</a></li>
<li><a href="#guava-cache">Guava Cache</a></li>
<li><a href="#caffeine">Caffeine</a></li>
<li><a href="#ehcache">Ehcache</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98%E5%AF%B9%E6%AF%94">进程内缓存对比</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">四、分布式缓存</a>
<ul>
<li><a href="#memcached">Memcached</a></li>
<li><a href="#redis">Redis</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%AF%B9%E6%AF%94">分布式缓存对比</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">五、多级缓存</a>
<ul>
<li><a href="#%E6%95%B4%E4%BD%93%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6">整体缓存框架</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">使用进程内缓存</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">使用分布式缓存</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">使用多级缓存</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">六、缓存问题</a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">缓存雪崩</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存穿透</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">七、缓存策略</a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">缓存预热</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%BC%93%E5%AD%98">如何缓存</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">缓存更新</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-缓存简介"><a class="markdownIt-Anchor" href="#一-缓存简介"></a> 一、缓存简介</h2>
<h3 id="什么是缓存"><a class="markdownIt-Anchor" href="#什么是缓存"></a> 什么是缓存</h3>
<p><strong>缓存就是数据交换的缓冲区</strong>。<strong>缓存的本质是一个内存 Hash</strong>。</p>
<p>缓存是一种利用空间换时间的设计，其目标就是<strong>更快</strong>、<strong>更近</strong>：</p>
<ul>
<li>将数据写入/读取速度<strong>更快</strong>的存储（设备）；</li>
<li>将数据缓存到离应用<strong>最近</strong>的位置；</li>
<li>将数据缓存到离<strong>用户</strong>最近的位置。</li>
</ul>
<p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。</p>
<p><strong>缓存命中率</strong>是缓存的重要度量指标，命中率越高越好。</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">缓存命中率 </span>=<span class="string"> 从缓存中读取次数 / 总读取次数</span></span><br></pre></td></tr></table></figure>
<h3 id="何时需要缓存"><a class="markdownIt-Anchor" href="#何时需要缓存"></a> 何时需要缓存</h3>
<p>引入缓存，会增加系统的复杂度。所以，引入缓存前，需要先权衡是否值得，考量点如下：</p>
<ul>
<li><strong>CPU 开销</strong> - 如果应用某个计算需要消耗大量 CPU，可以考虑缓存其计算结果。典型场景：复杂的、频繁调用的正则计算；分布式计算中间状态等。</li>
<li><strong>IO 开销</strong> - 如果数据库连接池比较繁忙，可以考虑缓存其查询结果。</li>
</ul>
<p>在数据层引入缓存，有以下几个好处：</p>
<ul>
<li>提升数据读取速度。</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力。</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。</li>
</ul>
<h3 id="缓存的基本原理"><a class="markdownIt-Anchor" href="#缓存的基本原理"></a> 缓存的基本原理</h3>
<p>根据业务场景，通常缓存有以下几种使用方式：</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。</li>
</ul>
<h3 id="缓存淘汰策略"><a class="markdownIt-Anchor" href="#缓存淘汰策略"></a> 缓存淘汰策略</h3>
<p>缓存淘汰的类型：</p>
<ul>
<li><strong>基于空间</strong> - 设置缓存空间大小。</li>
<li><strong>基于容量</strong> - 设置缓存存储记录数。</li>
<li><strong>基于时间</strong>
<ul>
<li>TTL（Time To Live，即存活期）缓存数据从创建到过期的时间。</li>
<li>TTI（Time To Idle，即空闲期）缓存数据多久没被访问的时间。</li>
</ul>
</li>
</ul>
<p>缓存淘汰算法：</p>
<ul>
<li><strong>FIFO</strong> - <strong>先进先出</strong>。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</li>
<li><strong>LRU</strong> - <strong>最近最少使用算法</strong>。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</li>
<li><strong>LFU</strong> - <strong>最近最少频率使用</strong>。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。</li>
</ul>
<p>这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。</p>
<h2 id="二-缓存的分类"><a class="markdownIt-Anchor" href="#二-缓存的分类"></a> 二、缓存的分类</h2>
<p>缓存从部署角度，可以分为客户端缓存和服务端缓存。</p>
<p><strong>客户端缓存</strong></p>
<ul>
<li><strong>HTTP 缓存</strong></li>
<li><strong>浏览器缓存</strong></li>
<li><strong>APP 缓存</strong>
<ul>
<li>Android</li>
<li>IOS</li>
</ul>
</li>
</ul>
<p><strong>服务端缓存</strong></p>
<ul>
<li><strong>CDN 缓存</strong> - 存放 HTML、CSS、JS 等静态资源。</li>
<li><strong>反向代理缓存</strong> - 动静分离，只缓存用户请求的静态资源。</li>
<li><strong>数据库缓存</strong> - 数据库（如 Mysql）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。</li>
<li><strong>进程内缓存</strong> - 缓存应用字典等常用数据。</li>
<li><strong>分布式缓存</strong> - 缓存数据库中的热点数据。</li>
</ul>
<blockquote>
<p>其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。</p>
<p>后端开发一般聚焦于进程内缓存、分布式缓存。</p>
</blockquote>
<h3 id="http-缓存"><a class="markdownIt-Anchor" href="#http-缓存"></a> HTTP 缓存</h3>
<h3 id="cdn-缓存"><a class="markdownIt-Anchor" href="#cdn-缓存"></a> CDN 缓存</h3>
<blockquote>
<p><strong>CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）</strong>。</p>
<p>国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png"/></div>
<h4 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h4>
<p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署 CDN 应用前的网络路径：</p>
<ul>
<li>请求：本机网络（局域网）=&gt; 运营商网络 =&gt; 应用服务器机房</li>
<li>响应：应用服务器机房 =&gt; 运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p>
<p>（2）部署 CDN 应用后网络路径：</p>
<ul>
<li>请求：本机网络（局域网） =&gt; 运营商网络</li>
<li>响应：运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p>
<p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。</p>
<h4 id="cdn-特点"><a class="markdownIt-Anchor" href="#cdn-特点"></a> CDN 特点</h4>
<p><strong>优点</strong></p>
<ul>
<li><strong>本地 Cache 加速</strong> - 提升访问速度，尤其含有大量图片和静态页面站点；</li>
<li><strong>实现跨运营商的网络加速</strong> - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li>
<li><strong>远程加速</strong> - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li>
<li><strong>带宽优化</strong> - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li><strong>集群抗攻击</strong> - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>不适宜缓存动态资源</strong>
<ul>
<li>解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</li>
</ul>
</li>
<li><strong>存在数据的一致性问题</strong>
<ul>
<li>解决方案（主要是在性能和数据一致性二者间寻找一个平衡）</li>
<li>设置缓存失效时间（1 个小时，过期后同步数据）。</li>
<li>针对资源设置版本号。</li>
</ul>
</li>
</ul>
<h3 id="反向代理缓存"><a class="markdownIt-Anchor" href="#反向代理缓存"></a> 反向代理缓存</h3>
<blockquote>
<p><strong>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</strong></p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png"/></div>
<h4 id="反向代理缓存原理"><a class="markdownIt-Anchor" href="#反向代理缓存原理"></a> 反向代理缓存原理</h4>
<p>反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。</p>
<p>反向代理缓存的原理：</p>
<ul>
<li>如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。</li>
<li>如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。</li>
</ul>
<p>这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p>
<p><strong>反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理</strong>。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p>
<h4 id="反向代理缓存比较"><a class="markdownIt-Anchor" href="#反向代理缓存比较"></a> 反向代理缓存比较</h4>
<p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p>
<ul>
<li>Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；</li>
<li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li>
<li>Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li>
<li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；</li>
<li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。</li>
</ul>
<h2 id="三-进程内缓存"><a class="markdownIt-Anchor" href="#三-进程内缓存"></a> 三、进程内缓存</h2>
<blockquote>
<p>进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p>
</blockquote>
<ul>
<li><code>硬盘缓存</code> - 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</li>
<li><code>内存缓存</code> - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</li>
</ul>
<p>常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。</p>
<h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3>
<p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：<strong>不需要淘汰的缓存数据</strong>。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h3 id="lruhashmap"><a class="markdownIt-Anchor" href="#lruhashmap"></a> LRUHashMap</h3>
<p>可以通过<strong>继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code></strong>。重写 <code>removeEldestEntry</code> 方法，即可完成一个简单的最近最少使用算法。</p>
<p>缺点：</p>
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
<h3 id="guava-cache"><a class="markdownIt-Anchor" href="#guava-cache"></a> Guava Cache</h3>
<p>解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 采用了类似 <code>ConcurrentHashMap</code> 的思想，分段加锁，减少锁竞争。</p>
<p>Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="caffeine"><a class="markdownIt-Anchor" href="#caffeine"></a> Caffeine</h3>
<p>Caffeine 实现了 W-TinyLFU(<strong>LFU</strong> + <strong>LRU</strong> 算法的变种)，其<strong>命中率和读写吞吐量大大优于 Guava Cache</strong>。</p>
<p>其实现原理较复杂，可以参考<a href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment" target="_blank" rel="noopener">你应该知道的缓存进化史</a>。</p>
<h3 id="ehcache"><a class="markdownIt-Anchor" href="#ehcache"></a> Ehcache</h3>
<p>EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。</p>
<p>优点</p>
<ul>
<li>快速、简单</li>
<li>支持多种缓存策略：LRU、LFU、FIFO 淘汰算法</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过 RMI、可插入 API 等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供 Hibernate 的缓存实现</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>使用磁盘 Cache 的时候非常占用磁盘空间</strong></li>
<li><strong>不保证数据的安全</strong></li>
<li>虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。</li>
</ul>
<h3 id="进程内缓存对比"><a class="markdownIt-Anchor" href="#进程内缓存对比"></a> 进程内缓存对比</h3>
<p>常用进程内缓存技术对比：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody>
<tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法,LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：<strong>如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 <code>Caffeine</code></strong>。</p>
<h2 id="四-分布式缓存"><a class="markdownIt-Anchor" href="#四-分布式缓存"></a> 四、分布式缓存</h2>
<blockquote>
<p><strong>分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存</strong>。</p>
<p>分布式缓存的应用场景：</p>
<ul>
<li>缓存经过复杂计算得到的数据</li>
<li>缓存系统中频繁访问的热点数据，减轻数据库压力</li>
</ul>
</blockquote>
<p>不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。</p>
<h3 id="memcached"><a class="markdownIt-Anchor" href="#memcached"></a> Memcached</h3>
<blockquote>
<p><a href="https://memcached.org/" target="_blank" rel="noopener">Memcached</a> 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p>
<p>简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。</p>
</blockquote>
<h4 id="memcached-特性"><a class="markdownIt-Anchor" href="#memcached-特性"></a> Memcached 特性</h4>
<ul>
<li><strong>使用物理内存作为缓存区，可独立运行在服务器上</strong>。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcached 进程（不同端口）或者使用分布式 Memcached 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li>
<li><strong>使用 key-value 的方式来存储数据</strong>。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li>
<li><strong>协议简单，基于文本行的协议</strong>。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li>
<li><strong>基于 libevent 高性能通信</strong>。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li>
<li><strong>分布式能力取决于 Memcached 客户端，服务器之间互不通信</strong>。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。</li>
<li><strong>采用 LRU 缓存淘汰策略</strong>。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。</li>
<li><strong>内置了一套高效的内存管理算法</strong>。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。</li>
<li><strong>不支持持久化</strong>。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li>
</ul>
<h4 id="memcached-工作原理"><a class="markdownIt-Anchor" href="#memcached-工作原理"></a> Memcached 工作原理</h4>
<p>（1）内存管理</p>
<p>Memcached 利用 <strong>slab allocation</strong> 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。</p>
<p>这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。</p>
<p>（2）缓存淘汰策略</p>
<p>Memcached 的缓存淘汰策略是 <strong>LRU</strong> + 到期失效策略。</p>
<p>当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。</p>
<p>在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：<strong>Memcached 不会监控存入的 key/vlue 对是否过期</strong>，而是在获取 key 值时查看记录的时间戳，<strong>检查 key/value 对空间是否过期</strong>，这样可减轻服务器的负载。</p>
<p>（3）分区</p>
<p>Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。</p>
<p>具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。</p>
<p>而这种选取集群节点的算法常见的有三种：</p>
<ul>
<li><strong>哈希取余算法</strong> - 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong> 来决定数据映射到哪一个节点。</li>
<li><strong>一致性哈希算法</strong> - 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</li>
<li><strong>虚拟 Hash 槽算法</strong> - 使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>），这个范围一般 <strong>远远大于</strong> 节点数。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>。</li>
</ul>
<h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3>
<blockquote>
<p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。</p>
<p>Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
</blockquote>
<h4 id="redis-特性"><a class="markdownIt-Anchor" href="#redis-特性"></a> Redis 特性</h4>
<ul>
<li>
<p>支持多种数据类型 - string、hash、list、set、sorted set。</p>
</li>
<li>
<p>支持多种数据淘汰策略</p>
<ul>
<li><strong>volatile-lru</strong> - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong> - 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong> - 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong> - 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong> - 从所有数据集中任意选择数据进行淘汰</li>
<li><strong>noeviction</strong> - 禁止驱逐数据</li>
</ul>
</li>
<li>
<p>提供两种持久化方式 - RDB 和 AOF</p>
</li>
<li>
<p>通过 Redis cluster 提供集群模式。</p>
</li>
</ul>
<h4 id="redis-原理"><a class="markdownIt-Anchor" href="#redis-原理"></a> Redis 原理</h4>
<ul>
<li>缓存淘汰
<ul>
<li>Redis 有两种数据淘汰实现
<ul>
<li>消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它</li>
<li>积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。</li>
</ul>
</li>
</ul>
</li>
<li>分区
<ul>
<li>Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。</li>
<li>Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。</li>
</ul>
</li>
<li>主从复制
<ul>
<li>Redis 2.8 后支持异步复制。它有两种模式：
<ul>
<li><code>完整重同步（full resychronization）</code> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><code>部分重同步（partial resychronization）</code> - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
</li>
<li>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。</li>
<li>如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。</li>
</ul>
</li>
<li>数据一致性
<ul>
<li>Redis 不保证强一致性，因为这会使得集群性能大大降低。</li>
<li>Redis 是通过异步复制来实现最终一致性。</li>
</ul>
</li>
</ul>
<h3 id="分布式缓存对比"><a class="markdownIt-Anchor" href="#分布式缓存对比"></a> 分布式缓存对比</h3>
<p>不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200709224247.png" alt="img" /></p>
<p>这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>MemCache</th>
<th>Redis</th>
<th>Tair</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构</td>
<td>只支持简单的 Key-Value 结构</td>
<td>String,Hash, List, Set, Sorted Set</td>
<td>String,HashMap, List，Set</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>容量大小</td>
<td>数据纯内存，数据存储不宜过多</td>
<td>数据全内存，资源成本考量不宜超过 100GB</td>
<td>可以配置全内存或内存+磁盘引擎，数据容量可无限扩充</td>
</tr>
<tr>
<td>读写性能</td>
<td>很高</td>
<td>很高(RT0.5ms 左右)</td>
<td>String 类型比较高(RT1ms 左右)，复杂类型比较慢(RT5ms 左右)</td>
</tr>
<tr>
<td>过期策略</td>
<td>过期后，不删除缓存</td>
<td>有六种策略来处理过期数据</td>
<td>支持</td>
</tr>
</tbody>
</table>
<ul>
<li><code>MemCache</code> - 只适合基于内存的缓存框架；且不支持数据持久化和容灾。</li>
<li><code>Redis</code> - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。</li>
<li><code>Tair</code> - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。</li>
</ul>
<p>总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。</p>
<h2 id="五-多级缓存"><a class="markdownIt-Anchor" href="#五-多级缓存"></a> 五、多级缓存</h2>
<h3 id="整体缓存框架"><a class="markdownIt-Anchor" href="#整体缓存框架"></a> 整体缓存框架</h3>
<p>通常，一个大型软件系统的缓存采用多级缓存方案：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存整体架构.png" /></div>
<p>请求过程：</p>
<ol>
<li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li>
<li>如果 CDN 无缓存，则访问反向代理服务器；</li>
<li>如果反向代理服务器有缓存则直接返回；</li>
<li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li>
<li>应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li>
<li>如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li>
<li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li>
</ol>
<h3 id="使用进程内缓存"><a class="markdownIt-Anchor" href="#使用进程内缓存"></a> 使用进程内缓存</h3>
<p><strong>如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案</strong>。</p>
<p>对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:</p>
<ul>
<li>数据量不是很大且更新频率较低的数据。</li>
<li>如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。</li>
</ul>
<p>这种方案存在以下问题：</p>
<ul>
<li>如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。</li>
<li>由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。</li>
</ul>
<h3 id="使用分布式缓存"><a class="markdownIt-Anchor" href="#使用分布式缓存"></a> 使用分布式缓存</h3>
<p>如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。</p>
<p>其应用场景如图所示：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200611141419.png" alt="img" /></p>
<p>Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。</p>
<p>这种方案存在以下问题：</p>
<ol>
<li>缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。</li>
<li>访问分布式缓存服务会有一定的 I/O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。</li>
</ol>
<h3 id="使用多级缓存"><a class="markdownIt-Anchor" href="#使用多级缓存"></a> 使用多级缓存</h3>
<p>单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。</p>
<p>这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。</p>
<p>一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。</p>
<p>一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。</p>
<h4 id="多级缓存查询"><a class="markdownIt-Anchor" href="#多级缓存查询"></a> 多级缓存查询</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存2.png" width="600" /></div>
<p>多级缓存查询流程如下：</p>
<ol>
<li>首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。</li>
<li>接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。</li>
<li>最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。</li>
</ol>
<h4 id="多级缓存更新"><a class="markdownIt-Anchor" href="#多级缓存更新"></a> 多级缓存更新</h4>
<p>对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:</p>
<ul>
<li>设置成写入后多少时间后过期</li>
<li>设置成写入后多少时间刷新</li>
</ul>
<p>对于 L1 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。</p>
<p>为了解决进程内缓存不一致的问题，设计可以进一步优化:</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存3.png" /></div>
<p>通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。</p>
<h2 id="六-缓存问题"><a class="markdownIt-Anchor" href="#六-缓存问题"></a> 六、缓存问题</h2>
<h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3>
<p><strong>缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩</strong>。</p>
<p>举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>
<p>解决缓存雪崩的主要手段如下：</p>
<ul>
<li><strong>增加缓存系统可用性</strong>（事前）。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。</li>
<li><strong>采用多级缓存方案</strong>（事中）。例如：本地缓存（<strong>Ehcache</strong>/<strong>Caffine</strong>/<strong>Guava Cache</strong>） + 分布式缓存（<strong>Redis</strong>/ <strong>Memcached</strong>）。</li>
<li><strong>限流、降级、熔断方案</strong>（事中），避免被流量打死。如：使用 <strong>Hystrix</strong> 进行熔断、降级。</li>
<li>缓存如果支持<strong>持久化</strong>，可以在恢复工作后恢复数据（事后）。如：<strong>Redis</strong> 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<p>上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。</p>
<p>解决缓存雪崩的辅助手段如下：</p>
<ul>
<li><strong>监控缓存，弹性扩容</strong>。</li>
<li><strong>缓存的过期时间可以取个随机值</strong>。这么做是为避免缓存同时失效，使得数据库 IO 骤升。比如：以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。</li>
</ul>
<h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3>
<blockquote>
<p><strong>缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。</strong></p>
</blockquote>
<p>解决缓存穿透，一般有两种方法：</p>
<p>（一）缓存空值</p>
<p><strong>对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存</strong>。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透1.png" width="350px"/></div>
<p>采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。</p>
<p>（二）过滤不可能存在的数据</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透2.png" width="350px"/></div>
<p><strong>制定一些规则过滤一些不可能存在的数据</strong>。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。</p>
<blockquote>
<p>针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。</p>
<p>此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。</p>
<p>针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。</p>
<p>而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。</p>
</blockquote>
<h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3>
<p>缓存击穿是指，<strong>热点数据失效瞬间，大量请求直接访问数据库</strong>。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。</p>
<p>为了避免这个问题，我们可以采取下面的两个手段:</p>
<ul>
<li><strong>分布式锁</strong> - 锁住热点数据的 key，避免大量线程同时访问同一个 key。</li>
<li><strong>定时异步刷新</strong> - 可以对部分数据采取失效前自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。</li>
</ul>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。</p>
<ul>
<li>事前：Redis 高可用方案（<strong>Redis Cluster</strong> + <strong>主从</strong> + <strong>哨兵</strong>），避免缓存全面崩溃。</li>
<li>事中：（一）采用多级缓存方案，本地缓存（<strong>Ehcache</strong>/<strong>Caffine</strong>/<strong>Guava Cache</strong>） + 分布式缓存（<strong>Redis</strong>/ <strong>Memcached</strong>）。（二）限流 + 熔断 + 降级（<strong>Hystrix</strong>），避免极端情况下，数据库被打死。</li>
<li>事后：<strong>Redis</strong> 持久化（<strong>RDB</strong>+<strong>AOF</strong>），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<blockquote>
<p>分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。</p>
</blockquote>
<h2 id="七-缓存策略"><a class="markdownIt-Anchor" href="#七-缓存策略"></a> 七、缓存策略</h2>
<h3 id="缓存预热"><a class="markdownIt-Anchor" href="#缓存预热"></a> 缓存预热</h3>
<p>缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。</p>
<p>解决方案：</p>
<ul>
<li><strong>手动刷新缓存</strong>：直接写个缓存刷新页面，上线时手工操作下。</li>
<li><strong>应用启动时刷新缓存</strong>：数据量不大，可以在项目启动的时候自动进行加载。</li>
<li><strong>定时异步刷新缓存</strong></li>
</ul>
<h3 id="如何缓存"><a class="markdownIt-Anchor" href="#如何缓存"></a> 如何缓存</h3>
<h4 id="不过期缓存"><a class="markdownIt-Anchor" href="#不过期缓存"></a> 不过期缓存</h4>
<p>缓存更新模式：</p>
<ol>
<li>开启事务</li>
<li>写 SQL</li>
<li>提交事务</li>
<li>写缓存</li>
</ol>
<p><strong>不要把写缓存操作放在事务中，尤其是写分布式缓存</strong>。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。</p>
<p>这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。</p>
<h4 id="过期缓存"><a class="markdownIt-Anchor" href="#过期缓存"></a> 过期缓存</h4>
<p>采用<strong>懒加载</strong>。对于热点数据，可以设置较短的缓存时间，并定期异步加载。</p>
<h3 id="缓存更新"><a class="markdownIt-Anchor" href="#缓存更新"></a> 缓存更新</h3>
<p>一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将<strong>读请求和写请求串行化</strong>。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。</p>
<p>一般来说缓存的更新有两种情况:</p>
<ul>
<li>先删除缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<blockquote>
<p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p>
<p>你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。</p>
</blockquote>
<ul>
<li><strong>先删除缓存，再更新数据库</strong></li>
</ul>
<p>对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。</p>
<p>这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存更新.png" width="400px"/></div>
<p>对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。</p>
<p>先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。</p>
<ul>
<li><strong>先更新数据库，再删除缓存</strong></li>
</ul>
<blockquote>
<p>注：更推荐使用这种策略</p>
</blockquote>
<p>如果我们使用更新数据库，再删除缓存就能避免上面的问题。</p>
<p>但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。</p>
<ul>
<li>应该选择哪种更新策略</li>
</ul>
<p>通过上面的内容，我们知道，两种更新策略都存在并发问题。</p>
<p>但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且同时有一个并发写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p>如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。</p>
<blockquote>
<p>更详细的分析可以参考：<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析 </a></p>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b7593496fb9a009b62904fa">你应该知道的缓存进化史</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b849878e51d4538c77a974a">如何优雅的设计和使用缓存？</a></li>
<li><a href="https://www.jianshu.com/p/73ce0ef820f9" target="_blank" rel="noopener">理解分布式系统中的缓存架构(上)</a></li>
<li><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank" rel="noopener">缓存那些事</a></li>
<li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析 </a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/distributed-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/distributed-transaction/" class="post-title-link" itemprop="url">分布式事务基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-21 11:30:00" itemprop="dateCreated datePublished" datetime="2019-06-21T11:30:00+08:00">2019-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/distributed-transaction/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/distributed-transaction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式事务基本原理"><a class="markdownIt-Anchor" href="#分布式事务基本原理"></a> 分布式事务基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B">一、分布式事务简介</a>
<ul>
<li><a href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1">本地事务</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9">分布式事务的难点</a></li>
<li><a href="#cap-%E5%92%8C-base">CAP 和 BASE</a></li>
<li><a href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1">柔性事务</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A42pc">二、两阶段提交（2PC）</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A43pc">三、三阶段提交（3PC）</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-1">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-1">方案总结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1tcc">四、补偿事务（TCC）</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-2">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-2">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-2">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8">五、本地消息表</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-3">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-3">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-3">方案总结</a></li>
</ul>
</li>
<li><a href="#%E5%85%ADmq-%E4%BA%8B%E5%8A%A1">六、MQ 事务</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-4">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-4">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-4">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83saga">七、SAGA</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-5">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-5">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-5">方案总结</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a>
<ul>
<li><a href="#%E5%90%84%E6%96%B9%E6%A1%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">各方案使用场景</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1">分布式事务方案设计</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-分布式事务简介"><a class="markdownIt-Anchor" href="#一-分布式事务简介"></a> 一、分布式事务简介</h2>
<h3 id="本地事务"><a class="markdownIt-Anchor" href="#本地事务"></a> 本地事务</h3>
<p>学习分布式之前，先了解一下本地事务的概念。</p>
<p>事务简单来说：<strong>一个会话中所进行所有的操作，要么同时成功，要么同时失败</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.png" alt="img" /></p>
<p>具体来说，事务指的是满足 ACID 特性的一组操作，可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
<ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
<blockquote>
<p>💡 更详细的内容可以参考：<a href="https://dunwu.github.io/db-tutorial/#/sql/sql-interview?id=%e4%ba%8c%e3%80%81%e4%ba%8b%e5%8a%a1">事务</a></p>
</blockquote>
<h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p>
<p>有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种<strong>跨系统的事务为分布式事务</strong>，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>举个互联网常用的交易业务为例：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205112615.png" alt="img" /></p>
<p>上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205112518.png" alt="img" /></p>
<p>可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。</p>
<h3 id="分布式事务的难点"><a class="markdownIt-Anchor" href="#分布式事务的难点"></a> 分布式事务的难点</h3>
<ul>
<li><strong>事务的原子性</strong> 事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**都做或都不做（All or Nothing）**的原子性。</li>
<li><strong>事务的一致性</strong> 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</li>
<li><strong>事务的隔离性</strong> 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</li>
</ul>
<h3 id="cap-和-base"><a class="markdownIt-Anchor" href="#cap-和-base"></a> CAP 和 BASE</h3>
<p>CAP 定理又称为 CAP 原则，指的是：<strong>在一个分布式系统中， <code>一致性（C：Consistency）</code>、<code>可用性（A：Availability）</code> 和 <code>分区容忍性（P：Partition Tolerance）</code>，最多只能同时满足其中两项</strong>。</p>
<p>BASE 是 <strong><code>基本可用（Basically Available）</code></strong>、<strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>💡 更详细的内容可以参考：<a href="#distributed-base-theory.md">分布式基础理论</a></p>
</blockquote>
<h3 id="柔性事务"><a class="markdownIt-Anchor" href="#柔性事务"></a> 柔性事务</h3>
<h4 id="柔性事务的概念"><a class="markdownIt-Anchor" href="#柔性事务的概念"></a> 柔性事务的概念</h4>
<p>在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了<strong>柔性事务</strong>的概念。</p>
<p>基于 BASE 理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h4 id="柔性事务的特性"><a class="markdownIt-Anchor" href="#柔性事务的特性"></a> 柔性事务的特性</h4>
<p>下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。</p>
<p><strong>可见性(对外可查询)</strong> 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。</p>
<p>为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。</p>
<p><strong>操作幂等性</strong> 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。</p>
<p>之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。</p>
<h2 id="二-两阶段提交2pc"><a class="markdownIt-Anchor" href="#二-两阶段提交2pc"></a> 二、两阶段提交（2PC）</h2>
<h3 id="方案简介"><a class="markdownIt-Anchor" href="#方案简介"></a> 方案简介</h3>
<p>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即<strong>将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段</strong>。事务的发起者称协调者，事务的执行者称参与者。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h3 id="处理流程"><a class="markdownIt-Anchor" href="#处理流程"></a> 处理流程</h3>
<p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
<h4 id="阶段-1准备阶段"><a class="markdownIt-Anchor" href="#阶段-1准备阶段"></a> 阶段 1：准备阶段</h4>
<ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。</li>
</ol>
<h4 id="阶段-2提交阶段"><a class="markdownIt-Anchor" href="#阶段-2提交阶段"></a> 阶段 2：提交阶段</h4>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况 1，当所有参与者均反馈 yes，提交事务</strong>：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205153529.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。</li>
<li>参与者执行 commit 请求，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack(应答)完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2，当任何阶段 1 一个参与者反馈 no，中断事务</strong>：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205154145.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出回滚请求（即 rollback 请求）。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<h3 id="方案总结"><a class="markdownIt-Anchor" href="#方案总结"></a> 方案总结</h3>
<p>2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li><strong>性能问题</strong> - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li><strong>可靠性问题</strong> - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li><strong>数据一致性问题</strong> - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h2 id="三-三阶段提交3pc"><a class="markdownIt-Anchor" href="#三-三阶段提交3pc"></a> 三、三阶段提交（3PC）</h2>
<h3 id="方案简介-2"><a class="markdownIt-Anchor" href="#方案简介-2"></a> 方案简介</h3>
<p>三阶段提交协议（Three-phase Commit，3PC），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>三阶段提交将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h3 id="处理流程-2"><a class="markdownIt-Anchor" href="#处理流程-2"></a> 处理流程</h3>
<h4 id="阶段-1cancommit"><a class="markdownIt-Anchor" href="#阶段-1cancommit"></a> 阶段 1：canCommit</h4>
<p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应(参与者不执行事务操作)，否则返回 no 响应：</p>
<ol>
<li>协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li>
</ol>
<h4 id="阶段-2precommit"><a class="markdownIt-Anchor" href="#阶段-2precommit"></a> 阶段 2：preCommit</h4>
<p>协调者根据阶段 1 canCommit 参与者的反应情况来决定是否可以基于事务的 preCommit 操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务：</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205180242.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 preCommit 请求，进入准备阶段。</li>
<li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li>
</ol>
</blockquote>
<p><strong>情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205205117.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 abort 请求。</li>
<li>无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ol>
</blockquote>
<h4 id="阶段-3docommit"><a class="markdownIt-Anchor" href="#阶段-3docommit"></a> 阶段 3：doCommit</h4>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交：</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205180425.png" alt="img" /></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。</li>
<li>参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>阶段 2 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205180515.png" alt="img" /></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，向所有参与者发出 abort 请求。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<p>注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<h3 id="方案总结-2"><a class="markdownIt-Anchor" href="#方案总结-2"></a> 方案总结</h3>
<p>优点：</p>
<ul>
<li>相比二阶段提交，三阶段降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</li>
</ul>
<h2 id="四-补偿事务tcc"><a class="markdownIt-Anchor" href="#四-补偿事务tcc"></a> 四、补偿事务（TCC）</h2>
<h3 id="方案简介-3"><a class="markdownIt-Anchor" href="#方案简介-3"></a> 方案简介</h3>
<p>TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>
<p>TCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现；</p>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
<p>TCC 事务的 Try、Confirm、Cancel 可以理解为 SQL 事务中的 Lock、Commit、Rollback。</p>
<h3 id="处理流程-3"><a class="markdownIt-Anchor" href="#处理流程-3"></a> 处理流程</h3>
<p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<h4 id="try-阶段"><a class="markdownIt-Anchor" href="#try-阶段"></a> Try 阶段</h4>
<p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务 TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
</ul>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<h4 id="confirm-cancel-阶段"><a class="markdownIt-Anchor" href="#confirm-cancel-阶段"></a> Confirm / Cancel 阶段</h4>
<p>根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p><strong>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205205200.png" alt="img" /></p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p><strong>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段</strong></p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205205221.png" alt="img" /></p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<h3 id="方案总结-3"><a class="markdownIt-Anchor" href="#方案总结-3"></a> 方案总结</h3>
<p>TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点:</p>
<ul>
<li><strong>性能提升</strong> - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li><strong>数据最终一致性</strong> - 基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li><strong>可靠性</strong> - 解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点： TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<h2 id="五-本地消息表"><a class="markdownIt-Anchor" href="#五-本地消息表"></a> 五、本地消息表</h2>
<h3 id="方案简介-4"><a class="markdownIt-Anchor" href="#方案简介-4"></a> 方案简介</h3>
<p>本地消息表的方案最初是由 ebay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>&quot;，或&quot;<strong>业务处理失败 + 事务消息发送成功</strong>&quot;的棘手情况出现，保证 2 个系统事务的数据一致性。</p>
<h3 id="处理流程-4"><a class="markdownIt-Anchor" href="#处理流程-4"></a> 处理流程</h3>
<p>下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。</p>
<p>为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205220246.png" alt="img" /></p>
<blockquote>
<ol>
<li><strong>步骤 1 事务主动方处理本地事务。</strong> 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中 1、2)。</li>
<li><strong>步骤 2 事务主动方通过 MQ 通知事务被动方处理事务</strong>。 消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。</li>
<li><strong>步骤 3 事务被动方通过 MQ 反会处理结果。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中 6 - 8)</li>
</ol>
</blockquote>
<p>为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<ul>
<li>当步骤 1 处理出错，事务回滚，相当于什么都没发生。</li>
<li>当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ul>
</blockquote>
<h3 id="方案总结-4"><a class="markdownIt-Anchor" href="#方案总结-4"></a> 方案总结</h3>
<p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可复用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h2 id="六-mq-事务"><a class="markdownIt-Anchor" href="#六-mq-事务"></a> 六、MQ 事务</h2>
<h3 id="方案简介-5"><a class="markdownIt-Anchor" href="#方案简介-5"></a> 方案简介</h3>
<p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<h3 id="处理流程-5"><a class="markdownIt-Anchor" href="#处理流程-5"></a> 处理流程</h3>
<p>下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ，相对于提供了 2PC 的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205230320.png" alt="img" /></p>
<blockquote>
<ol>
<li>发送方向 MQ 服务端(MQ Server)发送 half 消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ol>
</blockquote>
<p><strong>异常情况——事务主动方消息恢复</strong> 在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200205230412.png" alt="img" /></p>
<blockquote>
<ol start="5">
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>MQ Server 基于 commit / rollback 对消息进行投递或者删除</li>
</ol>
</blockquote>
<h3 id="方案总结-5"><a class="markdownIt-Anchor" href="#方案总结-5"></a> 方案总结</h3>
<p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量优于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="七-saga"><a class="markdownIt-Anchor" href="#七-saga"></a> 七、SAGA</h2>
<h3 id="方案简介-6"><a class="markdownIt-Anchor" href="#方案简介-6"></a> 方案简介</h3>
<p>Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文，Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<h3 id="处理流程-6"><a class="markdownIt-Anchor" href="#处理流程-6"></a> 处理流程</h3>
<p><strong>Saga 事务基本协议如下</strong>：</p>
<ul>
<li>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</li>
<li>每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</li>
</ul>
<p>可以看到，和 TCC 相比，Saga 没有“预留”动作，它的 Ti 就是直接提交到库。</p>
<p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga 的执行顺序有两种：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817d8ce9b4b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务执行顺序" /></p>
<ul>
<li>事务正常执行完成 T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。</li>
<li>事务回滚 T1, T2, …, Tj, Cj,…, C2, C1，其中 0 &lt; j &lt; n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。</li>
</ul>
<h4 id="恢复策略"><a class="markdownIt-Anchor" href="#恢复策略"></a> 恢复策略</h4>
<p>Saga 定义了两种恢复策略：</p>
<ul>
<li>向前恢复(forward recovery)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817da631d59c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务向前恢复" /></p>
<p>对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中 j 是发生错误的子事务(sub-transaction)。该情况下不需要 Ci。</p>
<ul>
<li>向后恢复(backward recovery)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817da706b3c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务向后恢复" /></p>
<p>对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p>
<p>Saga 事务常见的有两种不同的实现方式：命令协调和事件编排。</p>
<h4 id="命令协调"><a class="markdownIt-Anchor" href="#命令协调"></a> 命令协调</h4>
<ul>
<li><strong>命令协调(Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></li>
</ul>
<p>中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817daa1798dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="命令协调模式" /></p>
<p>以电商订单的例子为例：</p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务。</li>
<li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ol>
</blockquote>
<p>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<h4 id="事件编排"><a class="markdownIt-Anchor" href="#事件编排"></a> 事件编排</h4>
<ul>
<li><strong>事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</li>
</ul>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p>以电商订单的例子为例：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817dba9b2b61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="事件编排模式" /></p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑发布开始订单事件</li>
<li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件</li>
<li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件</li>
<li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件</li>
<li>主业务逻辑监听订单已支付事件并处理。</li>
</ol>
</blockquote>
<p>事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p>
<h3 id="方案总结-6"><a class="markdownIt-Anchor" href="#方案总结-6"></a> 方案总结</h3>
<p><strong>命令协调设计的优点和缺点：</strong></p>
<p>优点如下：</p>
<ul>
<li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器</li>
<li>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p><strong>事件/编排设计的优点和缺点</strong></p>
<p>优点如下：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<p>值得补充的是，由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性，当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h3 id="各方案使用场景"><a class="markdownIt-Anchor" href="#各方案使用场景"></a> 各方案使用场景</h3>
<p>介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817dc68ae74d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="方案比较" /></p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<h3 id="分布式事务方案设计"><a class="markdownIt-Anchor" href="#分布式事务方案设计"></a> 分布式事务方案设计</h3>
<p>本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。</p>
<p>实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。</p>
<blockquote>
<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询</p>
</blockquote>
<p>有些问题，看起来很重要，但实际上我们可以通过<strong>合理的设计</strong>或者将<strong>问题分解</strong>来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。</p>
<p>如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用<strong>人工解决</strong>的方式，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
<li><a href="https://juejin.im/post/5c0e5bf8e51d45063322fe50" target="_blank" rel="noopener">理解分布式事务</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/theory/distributed-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/theory/distributed-lock/" class="post-title-link" itemprop="url">分布式锁基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 23:42:00" itemprop="dateCreated datePublished" datetime="2019-06-04T23:42:00+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 15:46:26" itemprop="dateModified" datetime="2020-07-25T15:46:26+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/theory/distributed-lock/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="theory/distributed-lock/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式锁基本原理"><a class="markdownIt-Anchor" href="#分布式锁基本原理"></a> 分布式锁基本原理</h1>
<blockquote>
<p>在并发场景下，为了保证并发安全，我们常常要通过互斥（加锁）手段来保证数据同步安全。</p>
<p>JDK 虽然提供了大量锁工具，但是只能作用于单一 Java 进程，无法应用于分布式系统。为了解决这个问题，需要使用分布式锁。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现 ✅</li>
</ul>
<p>注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。</p>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%9D%E8%B7%AF">一、分布式锁思路</a></li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">二、数据库分布式锁</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86">数据库分布式锁原理</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%97%AE%E9%A2%98">数据库分布式锁问题</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B0%8F%E7%BB%93">数据库分布式锁小结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">三、Redis 分布式锁</a>
<ul>
<li><a href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86">Redis 分布式锁原理</a></li>
<li><a href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">Redis 分布式锁实现</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B0%8F%E7%BB%93-1">数据库分布式锁小结</a></li>
<li><a href="#redlock-%E7%AE%97%E6%B3%95">RedLock 算法</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9Bzookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">四、ZooKeeper 分布式锁</a>
<ul>
<li><a href="#zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86">ZooKeeper 分布式锁原理</a></li>
<li><a href="#zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">ZooKeeper 分布式锁实现</a></li>
<li><a href="#zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B0%8F%E7%BB%93">ZooKeeper 分布式锁小结</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">五、 分布式锁方案对比</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-分布式锁思路"><a class="markdownIt-Anchor" href="#一-分布式锁思路"></a> 一、分布式锁思路</h2>
<p>分布式锁的总体思路大同小异，仅在实现细节上有所不同。</p>
<p>分布式锁的主要思路如下：</p>
<ul>
<li><strong>互斥、可重入</strong> - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。
<ul>
<li>保证 key 唯一性的最简单的方式是使用 UUID。</li>
<li>存储锁的重入次数，以及分布式环境下唯一的线程标识。举例来说，可以使用 json 存储结构化数据，为了保证唯一，可以考虑将 mac 地址（IP 地址、机器 ID）、Jvm 进程 ID（应用 ID、服务 ID）、线程 ID 拼接起来作为唯一标识。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"count"</span>:<span class="number">1</span>,<span class="attr">"expireAt"</span>:<span class="number">147506817232</span>,<span class="attr">"jvmPid"</span>:<span class="number">22224</span>,<span class="attr">"mac"</span>:<span class="string">"28-D2-44-0E-0D-9A"</span>,<span class="attr">"threadId"</span>:<span class="number">14</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>避免死锁</strong> - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li>
<li><strong>容错</strong> - 只要大部分 Redis 节点可用，客户端就能正常加锁。</li>
<li><strong>自旋重试</strong> - 获取不到锁时，不要直接返回失败，而是支持一定的周期自旋重试，设置一个总的超时时间，当过了超时时间以后还没有获取到锁则返回失败。</li>
</ul>
<h2 id="二-数据库分布式锁"><a class="markdownIt-Anchor" href="#二-数据库分布式锁"></a> 二、数据库分布式锁</h2>
<h3 id="数据库分布式锁原理"><a class="markdownIt-Anchor" href="#数据库分布式锁原理"></a> 数据库分布式锁原理</h3>
<p>（1）创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<p>（2）获取锁</p>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<p>（3）释放锁</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h3 id="数据库分布式锁问题"><a class="markdownIt-Anchor" href="#数据库分布式锁问题"></a> 数据库分布式锁问题</h3>
<ul>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h3 id="数据库分布式锁小结"><a class="markdownIt-Anchor" href="#数据库分布式锁小结"></a> 数据库分布式锁小结</h3>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h2 id="三-redis-分布式锁"><a class="markdownIt-Anchor" href="#三-redis-分布式锁"></a> 三、Redis 分布式锁</h2>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h3 id="redis-分布式锁原理"><a class="markdownIt-Anchor" href="#redis-分布式锁原理"></a> Redis 分布式锁原理</h3>
<p>这个分布式锁有 3 个重要的考量点：</p>
<ol>
<li>互斥（只能有一个客户端获取锁）</li>
<li>不能死锁</li>
<li>容错（只要大部分 redis 节点创建了这把锁就可以）</li>
</ol>
<p>对应的 Redis 指令如下：</p>
<ul>
<li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li><code>delete</code> - <code>delete key</code>：删除 key</li>
</ul>
<blockquote>
<p>注意：</p>
<p>不要将 setnx 和 expire 作为两个命令组合实现加锁，这样就<strong>无法保证原子性</strong>。如果客户端在 setnx 之后崩溃，那么将导致锁无法释放。正确的做法应是在 setnx 命令中指定 expire 时间。</p>
</blockquote>
<h3 id="redis-分布式锁实现"><a class="markdownIt-Anchor" href="#redis-分布式锁实现"></a> Redis 分布式锁实现</h3>
<p>（1）申请锁</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> resource_name <span class="comment">my_random_value NX PX 30000</span></span><br></pre></td></tr></table></figure>
<p>执行这个命令就 ok。</p>
<ul>
<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>
<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>
</ul>
<p>（2）释放锁</p>
<p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="数据库分布式锁小结-2"><a class="markdownIt-Anchor" href="#数据库分布式锁小结-2"></a> 数据库分布式锁小结</h3>
<p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p>
<p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>
<h3 id="redlock-算法"><a class="markdownIt-Anchor" href="#redlock-算法"></a> RedLock 算法</h3>
<p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>
<ol>
<li>获取当前时间戳，单位是毫秒；</li>
<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li>
<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>
<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>
<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>
</ol>
<p><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a> 。</p>
<h2 id="四-zookeeper-分布式锁"><a class="markdownIt-Anchor" href="#四-zookeeper-分布式锁"></a> 四、ZooKeeper 分布式锁</h2>
<h3 id="zookeeper-分布式锁原理"><a class="markdownIt-Anchor" href="#zookeeper-分布式锁原理"></a> ZooKeeper 分布式锁原理</h3>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h3 id="zookeeper-分布式锁实现"><a class="markdownIt-Anchor" href="#zookeeper-分布式锁实现"></a> ZooKeeper 分布式锁实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeperSession</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立zk session的watcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Receive watched event: "</span> + event.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以采用另一种方式，创建临时顺序节点：</p>
<p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> 		    <span class="comment">// 传入进去的locksRoot + “/” + productId</span></span><br><span class="line">		    <span class="comment">// 假设productId代表了一个商品id，比如说1</span></span><br><span class="line">		    <span class="comment">// locksRoot = locks</span></span><br><span class="line">		    <span class="comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">	 	    <span class="comment">// locks：10000000000，10000000001，10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="keyword">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lockNode.equals(locksRoot+<span class="string">"/"</span>+ locks.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">	  <span class="keyword">int</span> previousLockIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;</span><br><span class="line">	         	    previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">this</span>.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String waitNode, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除/locks/10000000000节点</span></span><br><span class="line">            <span class="comment">// 删除/locks/10000000001节点</span></span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, -<span class="number">1</span>);</span><br><span class="line">            lockNode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="zookeeper-分布式锁小结"><a class="markdownIt-Anchor" href="#zookeeper-分布式锁小结"></a> ZooKeeper 分布式锁小结</h3>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="五-分布式锁方案对比"><a class="markdownIt-Anchor" href="#五-分布式锁方案对比"></a> 五、 分布式锁方案对比</h2>
<p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐。</p>
<p>性能：</p>
<ul>
<li>Redis 分布式锁，其实<strong>需要自己不断自旋去尝试获取锁</strong>，比较消耗性能。</li>
<li>ZooKeeper 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li>
</ul>
<p>可靠性：</p>
<ul>
<li>如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；</li>
<li>而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</li>
</ul>
<p>综上分析，<strong>ZooKeeper 实现分布式锁更加的简单，可靠性更高</strong>。✅</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">分布式锁实现汇总</a></li>
<li><a href="https://www.jianshu.com/p/1c5c1a592088" target="_blank" rel="noopener">Redis 实现分布式锁，以及可重入锁思路</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/8/">8</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">444k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:43</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
